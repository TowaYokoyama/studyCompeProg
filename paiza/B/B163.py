"""
Paiza.B.B163 の Docstring

B163:PAIZA山脈
26秒経過
6時間経過で時間切れ
PAIZA山脈はいくつかの山が横一列に連なってできています。
あなたは PAIZA 山脈をなす山のおおまかな大きさを知るために、ポイントを定めて写真を撮影しました。

写真は縦 H 個、横 W 個の値が 0 か 1 のピクセルの集合体であり、写真中の山とは値が 1 の連結なピクセルの集合のことを指します。
ここであるピクセル p について、p の上下左右に隣接するピクセルであって p と同じ値であるとき、p とそのピクセル同士は連結であると言います。
ただし、値が 0 のピクセルの上に値が 1 のピクセルが存在することはありません。

より具体的には以下の画像のように、値が 1 のピクセルのみからなる大きな塊が山となります。

図1

山がいくつか写った写真が与えられます。
山の大きさを山をなすピクセルの数としたとき、一番大きな山の大きさを出力してください。
図2

入力例 1 では写真の中にひとつの山があります。
この山をなす値が 1 のピクセルは 19 個なので、19 と出力してください。
評価ポイント
10回のテストケースで、正答率、実行速度、メモリ消費量をはかり得点が決まります。
より早い解答時間で提出したほうが得点が高くなります。
複数のテストケースで正しい出力がされるか評価（+50点）
解答までの速さ評価（+50点）
入力される値
入力は以下のフォーマットで与えられます。

H W
r_1
r_2
...
r_H
・1 行目に写真の縦の大きさを表す整数 H と写真の横の大きさを表す整数 W が半角スペース区切りで与えられます。
・続く 2 行目から H+1 行目にかけて、写真の i (1 ≦ i ≦ H) 行目のデータが長さ W の文字列 r_i が与えられます。
　・r_{i,j} (1 ≦ i ≦ H, 1 ≦ j ≦ W) は写真の i 行 j 列目のピクセルの値を表します。
・入力は合計で H+1 行となり、末尾に改行が 1 つ入ります。

それぞれの値は文字列で標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
山の大きさを山をなすピクセルの数としたとき、一番大きな山の大きさを出力してください。

末尾に改行を入れ、余計な文字、空行を含んではいけません。

条件
すべてのテストケースにおいて、以下の条件をみたします。

・1 ≦ H, W ≦ 500
・r_i (1 ≦ i ≦ H) は '0' もしくは '1' からなる文字列
・|r_i| = W (1 ≦ i ≦ H)
・r_{i,j} = '0' のとき r_{i-1,j} = '0' (2 ≦ i ≦ H, 1 ≦ j ≦ W))
入力例1
5 8
00000100
00001100
00011100
00111110
11111111
出力例1
19
入力例2
7 19
0010000000000000000
0111000000000000000
0111100000000000000
0111100000000011000
1111100000000011000
1111110001110011110
1111111001111111110
出力例2
30

"""

from collections import deque

H,W = map(int,input().split())
s = [input() for _ in range(H)]

visited = [[False] *W for _ in range(H)]

#初期値をいれると自動で判定してくれる関数にしてみる 上下左右が1なら、キューに入れたる　+1もする
def bfs(si,sj):
    cnt = 1 
    queue = deque([(si,sj)])
    visited[si][sj] = True 

    while queue:
        x,y = queue.popleft()#
        for dx,dy in[(1,0), (0,1), (-1,0), (0,-1)]:
            nx,ny = x+dx,y+dy
            if 0<=nx<H and 0<=ny<W:
                if s[nx][ny] == '1' and not visited[nx][ny]:
                    visited[nx][ny] = True
                    queue.append((nx,ny))
                    cnt += 1
                    
    return cnt
                    

#for文でやっていってs[i][j] == 1で未訪問かどうかでbfs関数を発火させるイメージ   
ans = 0 
for i in range(H):
    for j in range(W):
        if s[i][j] == '1' and not visited[i][j]:
            ans = max(ans,bfs(i,j))
            
print(ans)

N,H,W = map(int,input().split())
sy,sx = map(int,input().split())
s = input().strip()
grid = [list(map(int,input().split())) for _ in range(H)]

y,x = sy-1,sx-1 #インデント対策

for ch in s:
    if ch == 'F':
        y -=1
        
    elif ch == 'R':
        x+=1
        
    elif ch == 'L':
        x -=1 
    else:
        y+=1 
        
    
    print(grid[y][x])