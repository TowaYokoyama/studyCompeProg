"""
paiza.B.B157 の Docstring


入力は以下のフォーマットで与えられます。

N K
p_{1,1} p_{1,2} ... p_{1,K}
p_{2,1} p_{2,2} ... p_{2,K}
...
p_{N,1} p_{N,2} ... p_{N,K}
・1 行目にスーパーの数を表す整数 N と買いたい野菜の種類の数 K が半角スペース区切りで与えられます。
・2 行目から N+1 行目まで i (1 ≦ i ≦ N) 軒目のスーパーでの j (1 ≦ j ≦ K) 番目の野菜の価格が半角スペース区切りで与えられます。
・入力は合計で N+1 行となり、末尾に改行が 1 つ入ります。

それぞれの値は文字列で標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
スーパーを回って合計金額が一番安くなるように野菜を購入するとき、最低で何件のスーパーを回る必要があるか出力してください。
末尾に改行を入れ、余計な文字、空行を含んではいけません。

条件
すべてのテストケースにおいて、以下の条件をみたします。

・1 ≦ N, K ≦ 50
・1 ≦ p_{i,j} ≦ 1,000 (1 ≦ i ≦ N, 1 ≦ j ≦ K)
・p_{i,k} ≠ p_{j,k} (1 ≦ i < j ≦ N, 1 ≦ k ≦ K)
　・それぞれの野菜について、他店と同じ値段で販売されていることはない
入力例1
3 3
100 200 300
150 180 210
200 150 200
出力例1
2
入力例2
2 3
100 90 180
200 200 200
出力例2
1
"""
N,K = map(int,input().split())
p = [list(map(int,input().split())) for _ in range(N)]
#合計金額が一番安くなるため -> 一番安い野菜を全部取得
shops = set()
for k in range(K):
    min_price = 10** 9
    best_shop = -1
    for i in range(N):
        if p[i][k] < min_price:
            min_price = p[i][k]
            best_shop = i 
    shops.add(best_shop)
            
print(len(shops))