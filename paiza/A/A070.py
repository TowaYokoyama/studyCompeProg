"""
世界のどこかにパイザ大陸という大陸があります。
パイザ大陸は横に長い形状をしており、その土地は縦 2 マス × 横 W マスのグリッドで表されます。

大陸には N 個の国が存在しており、それぞれ 1, 2, ... , N と番号づけられています。
各マスはちょうど 1 つの国の領土であり、すべての i = 1, 2, ..., N について国 i の領土は次の条件を満たしています。

1. 国 i は 1 マス以上の領土を持っている。
2. 国 i の領土である任意の 2 つのマス C, C' に対して、上下左右に隣接する国 i の領土のみを通って C から C' に移動できる。

どの国も、ちょうど 1 種類の農作物を栽培しています。
また、隣接する国では必ず異なる農作物を栽培していることがわかっています。
ここで、国 i と国 j が隣接するとは、国 i の領土と国 j の領土が少なくとも 1 つの辺を共有することをいいます。

パイザ大陸全体で、少なくとも何種類の農作物が栽培されているでしょうか？

次の図は入力例 1 に対応しています。
国 1 と国 4 がトマトを、国 2 がキャベツを、国 3 と国 5 がナスを栽培している場合、パイザ大陸全体で栽培されている農作物は 3 種類になります。
この例では、パイザ大陸全体で栽培されている農作物が 2 種類以下であることはありえないため、答えは 3 となります。



評価ポイント
10個のテストケースを入力し、正答数と解答の提出までに要した時間を測定し得点が決まります。
※提出いただいたコードは複数回実行され、一度の実行では1つのテストケースのみ入力
※制限時間を超えるとテストケースが通っても失格(0点)となります。
得点の計算方法：正解数得点(50点) ＋ 正解率×解答時間得点(2時間以内で50点、4時間以内で25点、6時間で0点と線形に点数が落ちます)
10個のテストケースで正しい出力がされるか評価 (50点)
解答の提出までに要した時間による評価 (50点)
入力される値
入力は次のフォーマットで与えられます。
W N
C_{1,1} C_{1,2} ... C_{1,W}
C_{2,1} C_{2,2} ... C_{2,W}

・1 行目には、パイザ大陸の横幅を表す整数 W、および、パイザ大陸に存在する国の数を表す整数 N がこの順で半角スペース区切りで与えられます。
・続く 2 行のうちの i 行目 (1 ≦ i ≦ 2) には、パイザ王国の i 行目の各マスがどの国の領土であるかを表す W 個の整数がこの順で半角スペース区切りで与えられます。i 行目の j 番目 (1 ≦ j ≦ W) の整数 C_{i, j} は、i 行 j 列の位置にあるマスが国 C_{i, j} の領土であることを表しています。
・入力は合計で 3 行となり、入力値最終行の末尾に改行が 1 つ入ります。

文字列は標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
パイザ大陸全体で栽培されている農作物の種類として、考えられる最小の整数を出力してください。
末尾に改行を入れ、余計な文字、空行を含んではいけません。
条件
すべてのテストケースにおいて、以下の条件をみたします。
・1 ≦ W ≦ 100,000
・1 ≦ N ≦ 2 × W
・1 ≦ C_{i, j} ≦ N (1 ≦ i ≦ 2, 1 ≦ j ≦ W)
・C_{i, j} (1 ≦ i ≦ 2, 1 ≦ j ≦ W) は問題文中の条件 1, 2 を満たす

言語別実行時間制限の詳細は こちら をご確認ください。
入力例1
8 5
1 2 2 2 4 4 4 5
1 2 3 2 2 2 5 5
出力例1
3
入力例2
3 3
2 1 3
2 2 3
出力例2
3
"""
from collections import deque
W,N = map(int,input().split())
C = [list(map(int, input().split())) for _ in range(2)]
# print(C)
# ans = 0
"""
有向グラフで隣接リストを管理する
bfs
1 -- 2
|    |
2 -- 1なら偶数サイクルで2色
1
|\
| \
3--2なら奇数サイクルより3色
"""
graph = [set() for _ in range(N+1)]
#横yを見る
for r in range(2):
    for c in range(W-1): #右を見るのはW-1まで
        a = C[r][c]
        b = C[r][c+1]
        if a != b:
            graph[a].add(b)
            graph[b].add(a)
#縦を見る
for c in range(W):
    a = C[0][c]
    b = C[1][c]
    if a!= b:
        graph[a].add(b)
        graph[b].add(a)
# N=1なら1色
if N == 1:
    print(1)
    exit()
       
colors = [-1] * (N+1)

for i in range(1,N+1):
    if colors[i] != -1:
        continue
    
    colors[i] = 0
    queue = deque([i])
    
    while queue:
        u = queue.popleft()
        
        for v in graph[u]:#隣接リストから見る
            
            if colors[v]==-1:
                colors[v] = 1- colors[u]
                queue.append(v)
            
            elif colors[v] == colors[u]:
                print(3)
                exit() 

print(2)