"""
063:長い数列

04秒経過
6時間経過で時間切れ
あなたは極秘ルートから入手したとある数列を調べています。
これまでの調査によって、この数列は次のような規則で作られていることがわかっています。

・最初の M_1 個の要素はすべて X_1 である。
・続く M_2 個の要素はすべて X_2 である。
・...
・最後の M_K 個の要素はすべて X_K である。
・ここで、数列の長さ N = M_1 + M_2 + ... + M_K は偶数である。

あなたの今回の仕事は、この数列の前半と後半がどのくらい似ているのかを調べることです。
数列の要素を順に A_1, A_2, ..., A_N とするとき、 |A_1 - A_{N/2 + 1}| + |A_2 - A_{N/2 + 2}| + ... + |A_{N/2} - A_N| を計算してください。

入出力例 1 では、数列は 1, 1, 7, 7, 7, 7, 1, 1, 1, 3 で与えられるので、求める値は 22 となります。



評価ポイント
10個のテストケースを入力し、正答数と解答の提出までに要した時間を測定し得点が決まります。
※提出いただいたコードは複数回実行され、一度の実行では1つのテストケースのみ入力
※制限時間を超えるとテストケースが通っても失格(0点)となります。
得点の計算方法：正解数得点(50点) ＋ 正解率×解答時間得点(2時間以内で50点、4時間以内で25点、6時間で0点と線形に点数が落ちます)
10個のテストケースで正しい出力がされるか評価 (50点)
解答の提出までに要した時間による評価 (50点)
入力される値
入力は次のフォーマットで与えられます。
K
M_1 X_1
M_2 X_2
...
M_K X_K

・1 行目には、数列を定めるために用いられる整数 K が与えられます。
・続く K 行のうちの i 行目 (1 ≦ i ≦ K) には、二つの整数 M_i と X_i がこの順で半角スペース区切りで与えられます。これは、数列の i 番目の部分が M_i 個の X_i からなることを表します。
・入力は合計で K + 1 行となり、入力値最終行の末尾に改行が 1 つ入ります。

文字列は標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
S
・|A_1 - A_{N/2 + 1}| + |A_2 - A_{N/2 + 2}| + ... + |A_{N/2} - A_N| の値を 1 行に出力してください。
・出力の最後に改行を入れ、余計な文字、空行を含んではいけません。
条件
すべてのテストケースにおいて、以下の条件をみたします。
・1 ≦ K ≦ 200,000
・1 ≦ M_i ≦ 1,000,000,000 (1 ≦ i ≦ K)
・0 ≦ X_i ≦ 10,000 (1 ≦ i ≦ K)
・M_1 + M_2 + ... + M_K は偶数
・X_i ≠ X_{i + 1} (1 ≦ i ≦ K - 1)

言語別実行時間制限の詳細は こちら をご確認ください。
入力例1
4
2 1
4 7
3 1
1 3
出力例1
22
入力例2
3
300 10
100 0
200 20
出力例2
3000
"""
K = int(input())
segment = []
for _ in range(K):
    M, X = map(int, input().split())
    segment.append((M, X))

#合計長の半分を求める　
half = sum(M for M, X in segment) // 2

#前半/後半のラン分割
front = []
back = [] 
pos = 0
for m,x in segment:
    if pos + m <= half:
        front.append((m,x))
    elif pos >= half:
        back.append((m,x))
    else:
        #前半と後半にまたがる場合は、前半と後半に分割して追加する
        front.append((half - pos, x))
        back.append((pos + m - half, x))
    pos += m

#2ポインタで重なり区間を計算 
ans = 0
fi, bi = 0, 0
fr = front[0][0]
br = back[0][0]

while fi < len(front) and bi < len(back):
    fx = front[fi][1]
    bx = back[bi][1]
    overlap = min(fr, br)
    
    ans += abs(fx - bx) * overlap
    
    fr -= overlap
    br -= overlap
    
    if fr == 0:
        fi += 1
        if fi < len(front):
            fr = front[fi][0]
    if br == 0:
        bi += 1
        if bi < len(back):
            br = back[bi][0]

print(ans)