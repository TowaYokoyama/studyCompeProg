"""
あなたは塗り絵をしています。 この塗り絵はグリッド状のマス目を塗って楽しむものです。
塗り絵を塗る際に赤、緑、青の 3 色しか使いません。
あなたはあるマスを塗る時に、上下左右に隣接する同じ色のマスもまとめて 1 回で塗ります。ただし、一度塗ったところを別の色で塗ると色が混ざってしまうので上塗りすることはできません。

塗り絵を塗った後になって、それぞれの色で何回ずつ塗ったか気になりました。
赤を "R", 緑を "G", 青を "B" で表された、塗り終わった塗り絵が与えられます。
赤、緑、青をそれぞれ何回ずつ塗ったかを出力するプログラムを作成してください。

入力例 1 は以下のようになります。



赤を 2 回、緑を 3 回、青を 1 回使っています。
評価ポイント
10個のテストケースを入力し、正答数と解答の提出までに要した時間を測定し得点が決まります。
※提出いただいたコードは複数回実行され、一度の実行では1つのテストケースのみ入力
※制限時間を超えるとテストケースが通っても失格(0点)となります。
得点の計算方法：正解数得点(50点) ＋ 正解率×解答時間得点(2時間以内で50点、4時間以内で25点、6時間で0点と線形に点数が落ちます)
10個のテストケースで正しい出力がされるか評価 (50点)
解答の提出までに要した時間による評価 (50点)
入力される値
入力は次のフォーマットで与えられます。
H W
s_1
s_2
...
s_H

・1 行目にそれぞれ絵の縦幅、横幅を表す整数 H, W がこの順で半角スペース区切りで与えられます。
・続く H 行のうちの i 行目 (1 ≦ i ≦ H) には、色を表す"R", "G", "B" からなる長さ W の文字列 s_i が与えられます。ただし、"R" の場合は赤色、”G” の場合は緑色、 "B" の場合は青色となります。
・入力は合計で H + 1 行となり、入力値最終行の末尾に改行が 1 つ入ります。

文字列は標準入力から渡されます。標準入力からの値取得方法はこちらをご確認ください
期待する出力
期待する出力は 1 行からなります。
それぞれ赤、緑、青の使った回数をこの順で半角スペース区切りで出力してください。
末尾に改行を入れ、余計な文字、空行を含んではいけません。
条件
すべてのテストケースにおいて、以下の条件をみたします。
・1 ≦ H, W ≦ 1,000
・s_i は半角英大文字 "R", "G", "B" のいずれかで構成される文字列 (1 ≦ i ≦ H)

言語別実行時間制限の詳細は こちら をご確認ください。
入力例1
5 5
RRRGG
RRRGG
BBBBB
RRGGG
GRGGG
出力例1
2 3 1
入力例2
3 2
RG
GB
BR
出力例2
2 2 2
"""
from collections import deque
H,W =map(int,input().split())
c = [input() for _ in range(H)]
# print(c)
#bfs
ans_r,ans_g,ans_b = 0,0,0
dirs = [(1,0),(-1,0),(0,1),(0,-1)]
visited = [[False]*W for _ in range(H)]

def bfs(sx,sy):
    color = c[sx][sy]
    q = deque([(sx,sy)])
    visited[sx][sy] = True 
    while q:
        x,y = q.popleft()
        
        for dx,dy in dirs:
            nx = x + dx 
            ny = y+dy 
            if 0<= nx<H and 0<= ny < W: 
                if not visited[nx][ny] and c[nx][ny] == color:
                    visited[nx][ny] = True 
                    q.append((nx,ny))

for i in range(H):
    for j in range(W):
        if not visited[i][j]:
         # ここで1回塗ったことになる
            if c[i][j] == 'R':
                ans_r += 1
            elif c[i][j] == 'G':
                ans_g += 1
            else:
                ans_b += 1 
            
            bfs(i, j)

print(ans_r, ans_g, ans_b)