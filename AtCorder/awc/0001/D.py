"""
AtCorder.awc.0001.D の Docstring
高橋君は東西に伸びる街道沿いで商売をしている商人です。この街道には N 個の町が一列に並んでおり、西から順に 1 番目、 2 番目、...、 N 番目と番号が付けられています。 i 番目の町で商売をすると A 
i
​	
  の利益が得られますが、滞在費として B 
i
​	
  円かかります。

高橋君は、これらの町の中からいくつかを選んで商売をすることにしました。ただし、高橋君の馬車には以下の制限があります。

訪れる町は、番号が連続している必要はないが、訪れる町の番号を小さい順に並べたとき、隣り合う番号の差がすべて K 以下でなければならない。つまり、訪れる町の番号を小さい順に p 
1
​	
 ,p 
2
​	
 ,…,p 
m
​	
  としたとき、すべての 1≤j≤m−1 について p 
j+1
​	
 −p 
j
​	
 ≤K が成り立つ必要がある。これは、馬車が一度に移動できる距離に限界があるためである。
高橋君が用意できる滞在費の総額は M 円です。訪れる町の滞在費の合計が M 円以下となるように町を選ぶとき、得られる利益の合計の最大値を求めてください。

なお、どの町も訪れない場合、利益の合計は 0 とします。

制約
1≤N≤200
1≤M≤200
1≤K≤N
1≤A 
i
​	
 ≤10 
9
 
1≤B 
i
​	
 ≤M
入力はすべて整数
入力
Copy
N M K
A 
1
​	
  B 
1
​	
 
A 
2
​	
  B 
2
​	
 
:
A 
N
​	
  B 
N
​	
 
1 行目には、町の数を表す N 、用意できる滞在費の総額を表す M 、一度に移動できる町の数の上限を表す K が、スペース区切りで与えられる。
2 行目から N+1 行目では、各町の情報が与えられる。
1+i 行目では、 i 番目の町で得られる利益 A 
i
​	
  と滞在費 B 
i
​	
  が、スペース区切りで与えられる。
出力
条件を満たすように町を選んだとき、得られる利益の合計の最大値を 1 行で出力せよ。

入力例 1
Copy
5 10 2
8 3
5 4
10 5
3 2
7 3
出力例 1
Copy
21
入力例 2
Copy
4 5 1
100 2
200 3
150 2
50 1
出力例 2
Copy
350
入力例 3
Copy
10 50 3
1000000000 10
500000000 8
800000000 12
300000000 5
600000000 15
900000000 20
400000000 7
700000000 11
200000000 6
550000000 9
出力例 3
Copy
3450000000

"""
N, M, K = map(int, input().split())
A = [0]*N
B = [0]*N
for i in range(N):
    A[i], B[i] = map(int, input().split())

NEG = -10**30  # -INF
dp = [[NEG]*(M+1) for _ in range(N)]

ans = 0  # 何も選ばない場合

for i in range(N):
    # --- 初期化（町iを単独で選ぶ） ---
    if B[i] <= M:
        dp[i][B[i]] = max(dp[i][B[i]], A[i])
        ans = max(ans, dp[i][B[i]])

    # --- 遷移（直前はi-K..i-1だけ） ---
    for j in range(max(0, i-K), i):
        for c in range(M+1):#町 j で終わって、費用 c 使ってる状態」
            if dp[j][c] == NEG:
                continue
            nc = c + B[i]#そこから町 i に行ったら費用は
            if nc > M:
                continue
            dp[i][nc] = max(dp[i][nc], dp[j][c] + A[i])
            ans = max(ans, dp[i][nc])
#そこから町 i に行ったら費用はっていう考えかdた
print(ans)
