"""
AtCorder.awc.0006.D の Docstring
問題文
高橋君は、直線状に並んだ N 個の区画（区画 1 から区画 N まで）からなる長い廊下の警備計画を立てています。すべての区画に警備が行き届くようにしなければなりません。

高橋君は M 人の警備員候補を集めました。各警備員候補 i （ 1≤i≤M ）は、区画 L 
i
​	
  から区画 R 
i
​	
  までの連続する範囲を担当することができます。つまり、警備員候補 i を配置すると、区画 L 
i
​	
 ,L 
i
​	
 +1,…,R 
i
​	
  のすべてに警備が行き届きます。

高橋君は、 N 個すべての区画に警備が行き届くようにしたいと考えています。具体的には、 M 人の警備員候補の中から何人かを選び、選んだ警備員たちが担当する区画の集合の和集合が {1,2,…,N} と一致するようにしたいです。ただし、各警備員候補は選ぶか選ばないかの二択であり、同じ候補を複数回選ぶことはできません。

このとき、配置する警備員の人数の最小値を求めてください。ただし、どのように警備員を選んでもすべての区画に警備を行き届かせることが不可能な場合は、 −1 を出力してください。

制約
1≤N≤10 
9
 
1≤M≤2×10 
5
 
1≤L 
i
​	
 ≤R 
i
​	
 ≤N （ 1≤i≤M ）
入力はすべて整数である
入力
Copy
N M
L 
1
​	
  R 
1
​	
 
L 
2
​	
  R 
2
​	
 
⋮
L 
M
​	
  R 
M
​	
 
1 行目には、区画の数を表す整数 N と、警備員候補の数を表す整数 M が、空白区切りで与えられる。
2 行目から M+1 行目では、各警備員候補が担当できる区画の範囲が与えられる。
i+1 行目（ 1≤i≤M ）では、警備員候補 i が担当できる区画の範囲の左端 L 
i
​	
  と右端 R 
i
​	
  が、空白区切りで与えられる。
出力
すべての区画に警備を行き届かせるために必要な警備員の最小人数を 1 行で出力してください。不可能な場合は −1 を出力してください。

入力例 1
Copy
10 3
1 5
3 7
6 10
出力例 1
Copy
2
入力例 2
Copy
15 4
1 3
5 8
10 12
13 15
出力例 2
Copy
-1
入力例 3
Copy
1000000000 5
1 300000000
200000000 500000000
400000000 700000000
600000000 900000000
800000000 1000000000
出力例 3
Copy
5
"""
import sys
input = sys.stdin.readline

N, M = map(int, input().split())

intervals = []
for _ in range(M):
    L, R = map(int, input().split())
    intervals.append((L, R))

# L昇順ソート
intervals.sort()

ans = 0
current = 1
i = 0

while current <= N:
    max_reach = current
    # current以下から始まる区間を全部見る
    while i < M and intervals[i][0] <= current:
        max_reach = max(max_reach, intervals[i][1])
        i += 1
    
    # 伸ばせなかった → 不可能
    if max_reach == current:
        print(-1)
        exit()
    
    ans += 1
    current = max_reach + 1

print(ans)
