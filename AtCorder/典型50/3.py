"""
AtCorder.typically90.3 の Docstring
問題文
N 個の都市があり、それぞれの都市に 1 から N までの番号が付けられています。 また、N−1 本の道路があり、i 本目 (1≤i≤N−1) の道路は都市 A 
i
​	
  と都市 B 
i
​	
  を双方向に結んでいます。 どの都市の間も、いくつかの道路を通って移動可能なものとなっています。

さて、あなたは整数 u, v (1≤u<v≤N) を自由に選び、都市 u と都市 v を双方向に結ぶ道路を 1 本だけ新設することができます。そこで、以下で定められる値を スコア とします。

同じ道を 2 度通らずにある都市から同じ都市に戻ってくる経路における、通った道の本数 （この値はただ 1 つに定まる）
スコアとして考えられる最大の値を出力してください。

制約
3≤N≤100000
1≤A 
i
​	
 <B 
i
​	
 ≤N (1≤i≤N−1)
どの都市の間も、いくつかの道路を通って移動可能
与えられる入力は全て整数
入力
入力は以下の形式で標準入力から与えられます。

N
A 
1
​	
  B 
1
​	
 
⋮
A 
N−1
​	
  B 
N−1
​	
 
出力
問題文で定義されたスコアとして考えられる最大値を出力してください。

入力例 1
Copy
3
1 2
2 3
出力例 1
Copy
3
都市 1 と 都市 3 の間に道路を建設します。そうすると、都市 1 → 都市 2 → 都市 3 → 都市 1 という経路で通る道の本数が 3 本となり、スコア 3 を達成できます。

入力例 2
Copy
5
1 2
2 3
3 4
3 5
出力例 2
Copy
4
都市 1 と 都市 5 の間に道路を建設します。そうすると、都市 1 → 都市 2 → 都市 3 → 都市 5 → 都市 1 という経路で通る道の本数が 4 本となり、スコア 4 を達成できます。

入力例 3
Copy
10
1 2
1 3
2 4
4 5
4 6
3 7
7 8
8 9
8 10
出力例 3
Copy
8
入力例 4
Copy
31
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
5 10
5 11
6 12
6 13
7 14
7 15
8 16
8 17
9 18
9 19
10 20
10 21
11 22
11 23
12 24
12 25
13 26
13 27
14 28
14 29
15 30
15 31
出力例 4
Copy
9
"""
from collections import deque
N = int(input())
G = [[] for _ in range(N)]
# GはG[i] は「都市 i から行ける隣の都市一覧」。

for _ in range(N-1):
  a,b = map(int,input().split())
  
  a-=1#1-index → 0-index に変換。
  b-=1#1-index → 0-index に変換。
  G[a].append(b)
  G[b].append(a)
  """
  1回目
  G = [
  [1],  # 都市0 → 都市1
  [0],  # 都市1 → 都市0
  []    # 都市2.  
  ]
  2回目
  G = [
  [1],        # 都市0 → 都市1
  [0, 2],     # 都市1 → 都市0, 都市2
  [1]         # 都市2 → 都市1
]

  """
  
def bfs(start):
  dist = [-1] * N 
  """
  dist[i] =
start から都市 i まで、道を何本通るか
-1 は
👉「まだ行ってない（未訪問）」
  """
  dist[start] = 0
  q = deque([start])
  
  while q:
    v = q.popleft()#qから一つ取り出す
    for nv in G[v]:
      if dist[nv] == -1:
        dist[nv] = dist[v] +1#距離を確定させる
        q.append(nv)
        
    far = 0 #一番遠い都市を探す
    for i in range(N):
      if dist[i]> dist[far]:
        far = i 
        
    return far,dist[far]
  
u, _ = bfs(0)#直径の端っこ u を見つける

v, diameter = bfs(u)#一番遠い距離 = 木の直径

print(diameter +1)