"""
問題文
N 段の階段があります。高橋君は現在、上り口(0 段目)にいます。 高橋君は一歩で 1 段か 2 段上ることができます。

ただし、a 
1
​	
 ,a 
2
​	
 ,a 
3
​	
 ,....a 
M
​	
  段目の床は壊れており、その段に足を踏み入れることは危険です。

壊れている床を踏まないようにしながら、最上段(N 段目)にたどりつくまでの移動方法は何通りあるでしょうか？ 総数を 1,000,000,007 で割った余りを求めてください。

制約
1≦N≦10 
5
 
0≦M≦N−1
1≦a 
1
​	
 <a 
2
​	
 < ... <a 
M
​	
 ≦N−1
入力
入力は以下の形式で標準入力から与えられます。

N M
a 
1
​	
 
a 
2
​	
 
.
.
.
a 
M
​	
 
出力
条件を満たすような移動方法の総数を、1,000,000,007 で割った余りを出力してください。

入力例 1
Copy
6 1
3
出力例 1
Copy
4
移動方法は以下の 4 通りです。

0→1→2→4→5→6
0→1→2→4→6
0→2→4→5→6
0→2→4→6
入力例 2
Copy
10 2
4
5
出力例 2
Copy
0
壊れている床を踏まないような移動方法がない場合もあります。

入力例 3
Copy
100 5
1
23
45
67
89
出力例 3
Copy
608200469
総数を 1,000,000,007 で割った余りを出力することに注意して下さい。

"""
mod = 10**9 + 7
N, M = map(int, input().split())

broken = set()
for _ in range(M):
    broken.add(int(input()))

dp = [0] * (N + 1)

# 0段目
dp[0] = 1

# 1段目
if 1 not in broken:
    dp[1] = 1
else:
    dp[1] = 0

# 2段目
if N >= 2:
    if 2 not in broken:
        dp[2] = (dp[1] + dp[0]) % mod
    else:
        dp[2] = 0

# 3段目以降
for i in range(3, N + 1):
    if i in broken:
        dp[i] = 0
    else:
        dp[i] = (dp[i-1] + dp[i-2]) % mod

print(dp[N])
