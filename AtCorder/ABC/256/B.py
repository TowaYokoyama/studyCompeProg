"""
AtCorder.ABC.256.B の Docstring
配点 : 200 点

問題文
高橋君は野球をモチーフにしたゲームを作ろうとしましたが、うまくコードが書けなくて困っています。
高橋君の代わりに次の問題を解くプログラムを作ってください。
マス 0, マス 1, マス 2, マス 3 の 4 つのマス目があります。はじめマスの上には何もありません。
また、整数 P があり、はじめ P=0 です。
正の整数からなる数列 A=(A 
1
​	
 ,A 
2
​	
 ,…,A 
N
​	
 ) が与えられるので、i=1,2,…,N について順番に次の操作を行います。

マス 0 に駒を 1 個置く。
マス上のすべての駒を番号が A 
i
​	
  大きいマスに進める。言い換えると、駒がマス x にあればその駒をマス x+A 
i
​	
  に移動する。
ただし移動先のマスが存在しない (すなわち x+A 
i
​	
  が 4 以上になる) 駒たちに関しては、それらを取り除いて P に取り除いた個数を加算する。
すべての操作を行った後の P の値を出力してください。

制約
1≤N≤100
1≤A 
i
​	
 ≤4
入力される値はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N
A 
1
​	
  A 
2
​	
  … A 
N
​	
 
出力
操作終了時点での P の値を出力せよ。

入力例 1
Copy
4
1 1 3 2
出力例 1
Copy
3
操作を説明すると次のようになり、操作終了時点での P の値は 3 になります。

i=1 での操作
マス 0 に駒を置く。この時点でマス 0 にコマが乗っている。
すべての駒を 1 大きいマスに進める。移動を終えた時点でマス 1 に駒が乗っている。
i=2 での操作
マス 0 に駒を置く。この時点でマス 0,1 にコマが乗っている。
すべての駒を 1 大きいマスに進める。移動を終えた時点でマス 1,2 に駒が乗っている。
i=3 での操作
マス 0 に駒を置く。この時点でマス 0,1,2 にコマが乗っている。
すべての駒を 3 大きいマスに進める。
この時、マス 1,2 にある駒は移動先のマスが存在しないため (それぞれ 1+3=4,2+3=5 なので) 、盤上から取り除いて P に 2 を加算する。P の値は 2 になる。
移動を終えた時点でマス 3 に駒が乗っている。
i=4 での操作
マス 0 に駒を置く。この時点でマス 0,3 にコマが乗っている。
すべての駒を 2 大きいマスに進める。
この時、マス 3 にある駒は移動先のマスが存在しないため (3+2=5 なので) 、盤上から取り除いて P に 1 を加算する。P の値は 3 になる。
移動を終えた時点でマス 2 に駒が乗っている。
入力例 2
Copy
3
1 1 1
出力例 2
Copy
0
P の値が操作中に変化しない場合もあります。

入力例 3
Copy
10
2 2 4 1 1 1 4 2 2 1
出力例 3
Copy
8

"""
N = int(input())
A = list(map(int, input().split()))
po = 0
li = [0,0,0,0]
for i in A:
  li[0] += 1
  if i == 1:
    if li[3] == 1:
      po += 1
    li[3] = li[2]
    li[2] = li[1]
    li[2] = li[1]
  elif i == 2:
    if li[3] == 1:
      po += 1
      li[2] == 1
    if li[2] == 1:
      po += 1
      li[2] = 1
      
    if li[1] == 1:
      li[3] = 1
      li[2] = 1
  elif i == 3:
    if li[3] == 1:
      po += 1
      li[3] = 1
      
    if li[2] == 1:
      po+= 1
      li[3] = 1
    if li[1] == 1:
      po+=1
      li[3] = 1
  else:
    po+= sum(li)
    li = [0,0,0,0]
print(po)



N = int(input())
A = list(map(int, input().split()))

po = 0
li = [0, 0, 0, 0]

for a in A:
    # マス0に1個置く
    li[0] += 1

    # 同時移動用
    new = [0, 0, 0, 0]

    for x in range(4):
        nx = x + a
        if nx >= 4:
            po += li[x]      # 盤外に出る
        else:
            new[nx] += li[x]

    li = new

print(po)


N = int(input())
A = list(map(int, input().split()))

po = 0
li = [0, 0, 0, 0]

for a in A:
    # マス0に1個置く
    li[0] += 1

    # 同時移動用
    new = [0, 0, 0, 0]

    if a == 1:
        for x in range(4):
            if li[x] == 0:
                continue
            nx = x + 1
            if nx >= 4:
                po += li[x]
            else:
                new[nx] += li[x]

    elif a == 2:
        for x in range(4):
            if li[x] == 0:
                continue
            nx = x + 2
            if nx >= 4:
                po += li[x]
            else:
                new[nx] += li[x]

    elif a == 3:
        for x in range(4):
            if li[x] == 0:
                continue
            nx = x + 3
            if nx >= 4:
                po += li[x]
            else:
                new[nx] += li[x]

    else:  # a == 4
        po += sum(li)
        new = [0, 0, 0, 0]

    li = new

print(po)

board = [0, 0, 0, 0]
P = 0

for a in A:
    board[0] += 1
    new = [0, 0, 0, 0]
    for x in range(4):
        nx = x + a
        if nx >= 4:
            P += board[x]
        else:
            new[nx] += board[x]
    board = new
