"""
AtCorder.ABC.258.D の Docstring
イによって構成されます。

初めて i 番目のステージをクリアするためにはストーリー映像の視聴とゲームプレイを両方行う必要がありますが、二回目以降はストーリー映像をスキップすることができるので、ゲームプレイのみでクリアすることができます。

初めから遊べるのは 1 番目のステージのみですが、i(1≤i≤N−1) 番目のステージをクリアすることにより、i+1 番目のステージも遊べるようになります。

合計 X 回ステージをクリアするために必要な時間の最小値を求めてください。ただし、同じステージを複数回クリアしたとしても、全てクリア回数に数えられます。

制約
1≤N≤2×10 
5
 
1≤A 
i
​	
 ,B 
i
​	
 ≤10 
9
 (1≤i≤N)
1≤X≤10 
9
 
入力は全て整数
入力
入力は以下の形式で標準入力から与えられる。

N X
A 
1
​	
  B 
1
​	
 
⋮
A 
N
​	
  B 
N
​	
 
出力
答えを出力せよ。

入力例 1
Copy
3 4
3 4
2 3
4 2
出力例 1
Copy
18
例えば、次のようにして 18 分で 4 回クリアすることができます。

ステージ 1 をクリアする。A 
1
​	
 +B 
1
​	
 =7 分かかる。
ステージ 2 をクリアする。A 
2
​	
 +B 
2
​	
 =5 分かかる。
ステージ 2 を再びクリアする。B 
2
​	
 =3 分かかる。
ステージ 2 を再びクリアする。B 
2
​	
 =3 分かかる。
17 分以内に 4 回クリアすることはできません。

入力例 2
Copy
10 1000000000
3 3
1 6
4 7
1 8
5 7
9 9
2 4
6 4
5 1
3 1
出力例 2
Copy
1000000076
"""
N, X = map(int, input().split())

A = []
B = []
for _ in range(N):
    a, b = map(int, input().split())
    A.append(a)
    B.append(b)

# 累積時間
# prefix[i] = ステージ1〜iまでを「初回クリア」した合計時間
prefix = [0] * (N + 1)

# prefix を作る（累積和）
for i in range(1, N + 1):
    prefix[i] = prefix[i - 1] + A[i - 1] + B[i - 1]

ans = 10**30  # 十分大きい値
min_B = 10**30  # 今までで一番小さい B

# i = 1〜N まで「最初に進むステージ数」を試す
for i in range(1, N + 1):
    min_B = min(min_B, B[i - 1])

    # i ステージ分は必ず初回クリア
    # それで i 回クリア
    if i > X:
        break

    # 残り回数
    rest = X - i

    # 合計時間
    total = prefix[i] + rest * min_B

    ans = min(ans, total)

print(ans)
