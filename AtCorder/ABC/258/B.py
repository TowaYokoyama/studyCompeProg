"""
AtCorder.ABC.258.B の Docstring

正整数 N が与えられます。

N 行 N 列のマス目があり、上から i 行目、左から j 列目のマスには数字 A 
i,j
​	
  が書かれています。

このマス目は上下および左右がつながっているものとします。つまり以下が全て成り立ちます。

(1,i) の上のマスは (N,i) であり、(N,i) の下のマスは (1,i) である。(1≤i≤N)
(i,1) の左のマスは (i,N) であり、(i,N) の右のマスは (i,1) である。(1≤i≤N)
高橋君は、上下左右および斜めの 8 方向のうちいずれかを初めに選びます。そして、好きなマスから決めた方向に 1 マス移動することを N−1 回繰り返します。

高橋君は N 個のマス上を移動することになりますが、高橋君が通ったマスに書かれている数字を左から通った順番に並べた整数としてあり得る最大のものを求めてください。

制約
1≤N≤10
1≤A 
i,j
​	
 ≤9
入力はすべて整数。
入力
入力は以下の形式で標準入力から与えられる。

N
A 
1,1
​	
 A 
1,2
​	
 …A 
1,N
​	
 
A 
2,1
​	
 A 
2,2
​	
 …A 
2,N
​	
 
⋮
A 
N,1
​	
 A 
N,2
​	
 …A 
N,N
​	
 
出力
答えを出力せよ。

入力例 1
Copy
4
1161
1119
7111
1811
出力例 1
Copy
9786
高橋君が上から 2 行目、左から 4 列目のマスから出発し、右下に進むことで、通ったマスに書かれた数字を並べ 9786 を作ることができます。 9786 より大きい値を作ることはできないため、9786 が解です。

入力例 2
Copy
10
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
1111111111
出力例 2
Copy
1111111111
32bit整数型に答えが収まるとは限らないことに注意してください。
"""
N = int(input())
A = [list(map(int, input())) for _ in range(N)]#空白なしで撮る.split()抜き
"""
A =
[
 [1, 1, 6, 1],
 [1, 1, 1, 9],
 [7, 1, 1, 1],
 [1, 8, 1, 1]
]

"""
dirs = [
    (-1, -1), (-1, 0), (-1, 1),
    ( 0, -1),          ( 0, 1),
    ( 1, -1), ( 1, 0), ( 1, 1)
] #移動のルール表
ans = '0'

for i in range(N):
    for j in range(N):
        for dx, dy in dirs:
            x, y = i, j
            s = "" #今から作る「N桁の数字列」
            for _ in range(N):
                s += str(A[x][y])
                # トーラス（はみ出したら戻す）
                x = (x + dx) % N #(0 + -1) % 4 = -1 % 4 = 3
                y = (y + dy) % N
            ans = max(ans, s)

print(ans)