"""
 H 行横 W 列のマス目があります。 上から i 行目 (1≤i≤H)、左から j 列目 (1≤j≤W) のマスをマス (i,j) と呼ぶことにします。

はじめ、マス (i,j) には強さ S 
i,j
​	
  のスライムがおり、マス (P,Q) にいるスライムが高橋くんです。

高橋くんが以下の行動を好きな回数（0 回でもよい）行ったあとの、高橋くんの強さとしてありえる最大値を求めてください。

高橋くんに隣接するスライムのうち、強さが高橋くんの強さの  
X
1
​	
  倍未満のものを選んで吸収する。 その結果、吸収されたスライムは消滅し、高橋君の強さは吸収したスライムの強さだけ増加する。
上記の行動の際、スライムが吸収され消滅したことで生じた隙間は直ちに高橋くんによって埋められ、消滅したスライムに隣接していたスライム（それらが存在すれば）は新たに高橋くんと隣接します（入出力例１の説明も参照してください）。

制約
1≤H,W≤500
1≤P≤H
1≤Q≤W
1≤X≤10 
9
 
1≤S 
i,j
​	
 ≤10 
12
 
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

H W X 
P Q
S 
1,1
​	
  S 
1,2
​	
  … S 
1,W
​	
 
S 
2,1
​	
  S 
2,2
​	
  … S 
2,W
​	
 
⋮
S 
H,1
​	
  S 
H,2
​	
  … S 
H,W
​	
 
出力
高橋くんが行動を行ったあとの高橋くんの強さとしてありえる最大値を出力せよ。

入力例 1
Copy
3 3 2
2 2
14 6 9
4 9 20
17 15 7
出力例 1
Copy
28
はじめ、それぞれのマスにいるスライムの強さは以下の図のようになっています。



例えば、高橋くんは次のように行動を行うことができます。



マス (2,1) にいるスライムを吸収する。高橋くんの強さは 9+4=13 となり、新たにマス (1,1) のスライムとマス (3,1) のスライムが高橋くんと隣接する。
マス (1,2) にいるスライムを吸収する。高橋くんの強さは 13+6=19 となり、新たにマス (1,3) のスライムが高橋くんと隣接する。
マス (1,3) にいるスライムを吸収する。高橋くんの強さは 19+9=28 となる。
以上の行動を行ったあと、高橋くんの強さは 28 となります。

高橋くんがどのように行動を行っても、高橋くんの強さを 28 より大きくすることはできないため、28 を出力してください。

高橋くんの強さの  
2
1
​	
  倍未満のスライムしか吸収できないことに注意してください。 例えば、上図の右側の状態からマス (1,1) にいるスライムを吸収することはできません。

入力例 2
Copy
3 4 1
1 1
5 10 1 1
10 1 1 1
1 1 1 1
出力例 2
Copy
5
高橋くんはどのスライムも吸収できません。

入力例 3
Copy
8 10 2
1 5
388 130 971 202 487 924 247 286 237 316
117 166 918 106 336 928 493 391 235 398
124 280 425 955 212 988 227 222 307 226
336 302 478 246 950 368 291 236 170 101
370 200 204 141 287 410 388 314 205 460
291 104 348 337 404 399 416 263 415 339
105 420 302 334 231 481 466 366 401 452
119 432 292 403 371 417 351 231 482 184
出力例 3
Copy
1343
"""
import heapq

H, W, X = map(int, input().split())
P, Q = map(int, input().split())
S = [list(map(int, input().split())) for _ in range(H)]

P -= 1
Q -= 1

visited = [[False] * W for _ in range(H)]
heap = []

strength = S[P][Q]
visited[P][Q] = True

dirs = [(1,0), (-1,0), (0,1), (0,-1)]

# 初期隣接をheapに入れる
for dr, dc in dirs:
    nr, nc = P + dr, Q + dc
    if 0 <= nr < H and 0 <= nc < W:
        heapq.heappush(heap, (S[nr][nc], nr, nc))

# メインループ
while heap:
    val, r, c = heapq.heappop(heap)

    if visited[r][c]:
        continue

    if val >= strength * X:
        break

    strength += val
    visited[r][c] = True

    for dr, dc in dirs:
        nr, nc = r + dr, c + dc
        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc]:
            heapq.heappush(heap, (S[nr][nc], nr, nc))

print(strength)