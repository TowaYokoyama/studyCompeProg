"""
AtCorder.ABC.257.B の Docstring
N 個のマスが左右一列に並んでおり、左から順にマス 1、マス 2、…、マス N と番号づけられています。
また、K 個のコマがあり、最初左から i 番目のコマはマス A 
i
​	
  に置かれています。
これらに対して、Q 回の操作を行います。 i 回目の操作では次の操作を行います。

左から L 
i
​	
  番目のコマが一番右のマスにあるならば何も行わない。
そうでない時、左から L 
i
​	
  番目のコマがあるマスの 1 つ右のマスにコマが無いならば、左から L 
i
​	
  番目のコマを 1 つ右のマスに移動させる。 1 つ右のマスにコマがあるならば、何も行わない。
Q 回の操作が終了した後の状態について、i=1,2,…,K に対して左から i 番目のコマがあるマスの番号を出力してください。

制約
1≤K≤N≤200
1≤A 
1
​	
 <A 
2
​	
 <⋯<A 
K
​	
 ≤N
1≤Q≤1000
1≤L 
i
​	
 ≤K
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N K Q
A 
1
​	
  A 
2
​	
  … A 
K
​	
 
L 
1
​	
  L 
2
​	
  … L 
Q
​	
 
出力
K 個の整数を空白区切りで一行に出力せよ。 ここで、i 個目の整数は、 Q 回の操作が終了した後の状態について、左から i 番目のコマの番号を表す。

入力例 1
Copy
5 3 5
1 3 4
3 3 1 1 2
出力例 1
Copy
2 4 5
最初、コマはマス 1, 3, 4 にあります。これに対して以下のように操作が行われます。

左から 3 番目のコマはマス 4 にあります。 これは一番右のマスでなく、その 1 つ右のマスにもコマが置かれていないため、左から 3 番目のコマをマス 5 に動かします。 コマはマス 1, 3, 5 にある状態になります。
左から 3 番目のコマはマス 5 にあります。 これは一番右のマスなので、何も行いません。 コマはマス 1, 3, 5 にある状態のままです。
左から 1 番目のコマはマス 1 にあります。 これは一番右のマスでなく、その 1 つ右のマスにもコマが置かれていないため、左から 1 番目のコマをマス 2 に動かします。 コマはマス 2, 3, 5 にある状態になります。
左から 1 番目のコマはマス 2 にあります。 これは一番右のマスでありませんが、その 1 つ右のマス（マス 3 ）にコマが置かれているため、何も行いません。 コマはマス 2, 3, 5 にある状態のままです。
左から 2 番目のコマはマス 3 にあります。 これは一番右のマスでなく、その右のマスにもコマが置かれていないため、左から 2 番目のコマをマス 4 に動かします。 コマはマス 2, 4, 5 にある状態になります。
よって、Q 回の操作が終わった後でコマはマス 2, 4, 5 に置かれているため、2,4,5 を空白区切りでこの順に出力します。

入力例 2
Copy
2 2 2
1 2
1 2
出力例 2
Copy
1 2
入力例 3
Copy
10 6 9
1 3 5 7 8 9
1 2 3 4 5 6 5 6 2
出力例 3
Copy
2 5 6 7 9 10
"""
N,K,Q = map(int,input().split()) #Nは駒の数　Kは駒 Qはクエリの数
A = list(map(int,input().split()))#K個の駒がマスAiに止まってるよ
L = list(map(int,input().split()))#A[LQ]のますに注目して操作してくよ
for l in L:
    i = l-1
    #一番右のマスなら何もしない
    if A[i] == N:
        continue
    
    #右にこまがあるかどうか
    if i+ 1 < K and A[i+1] == A[i]+1:
        continue
    
    #動かせる
    A[i] += 1
print(*A)