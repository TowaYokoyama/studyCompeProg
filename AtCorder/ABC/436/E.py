"""

配点 : 475 点

問題文
(1,2,…,N) を並べ替えた整数列 P=(P 
1
​	
 ,P 
2
​	
 ,…,P 
N
​	
 ) が与えられます。 ここで、P は (1,2,…,N) と等しくないことが保証されます。

あなたは、次の操作を 0 回以上行って P を列 (1,2,…,N) と一致させたいです。

1≤i<j≤N を満たす整数の組 (i,j) をひとつ選ぶ。P 
i
​	
  と P 
j
​	
  の値を入れ替える。
P を列 (1,2,…,N) と一致させるために必要な最小の操作回数を K 回とします。

K 回の操作で P を列 (1,2,…,N) と一致させるような操作列の 1 回目の操作としてあり得る操作の数を求めてください。 ただし、2 つの操作は選んだ整数の組 (i,j) が異なるとき、またそのときに限り区別します。

制約
2≤N≤3×10 
5
 
1≤P 
i
​	
 ≤N (1≤i≤N)
P 
i
​	
 

=P 
j
​	
  (1≤i<j≤N)
i

=P 
i
​	
  を満たす 1≤i≤N が存在する
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N
P 
1
​	
  P 
2
​	
  … P 
N
​	
 
出力
答えを出力せよ。

入力例 1
Copy
5
3 1 4 2 5
出力例 1
Copy
6
例えば、次のようにして 3 回の操作で目標を達成することができます。

(i,j)=(1,2) を選ぶ。P=(1,3,4,2,5) となる。
(i,j)=(2,4) を選ぶ。P=(1,2,4,3,5) となる。
(i,j)=(3,4) を選ぶ。P=(1,2,3,4,5) となる。
2 回以下の操作で目標を達成することはできないので、K=3 です。

上の説明の通り、最初の操作で (1,2) を選ぶと 3 回の操作で目標を達成できます。 その他にも、最初の操作で (1,3),(1,4),(2,3),(2,4),(3,4) のいずれかを選んだ場合にはそのあとの 2 回の操作を適切に行うことで P=(1,2,3,4,5) とすることができます。

よって、6 を出力してください。

入力例 2
Copy
2
2 1
出力例 2
Copy
1
入力例 3
Copy
20
15 5 13 17 9 11 20 4 14 16 6 3 8 19 12 7 10 18 2 1
出力例 3
Copy
77


 """
N = int(input())
P = [0] + list(map(int, input().split()))  # 1-indexed

visited = [False] * (N + 1)
ans = 0

for i in range(1, N + 1):
    if visited[i]:
        continue

    # i からサイクルを辿る
    cur = i
    length = 0
    while not visited[cur]:
        visited[cur] = True
        cur = P[cur]
        length += 1

    # サイクル長 length から組み合わせを足す
    ans += length * (length - 1) // 2

print(ans)
