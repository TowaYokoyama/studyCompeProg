"""
AtCorder.ABC.387.D の Docstring
H 行 W 列のグリッドがあります。 上から i 行目、左から j 列目のマスを (i,j) と表記します。

各マスはスタートマス・ゴールマス・空きマス・障害物マスのいずれかであり、その情報は H 個の長さ W の文字列 S 
1
​	
 ,S 
2
​	
 ,…,S 
H
​	
  によって表されます。 具体的には、マス (i,j) は S 
i
​	
  の j 文字目が S であるときスタートマス、G であるときゴールマス、. であるとき空きマス、# であるとき障害物マスです。 ここで、スタートマスとゴールマスはちょうど 1 つずつ存在することが保証されます。

あなたは今スタートマスにいます。 あなたの目標は、今いるマスと辺で隣接するマスに移動することを繰り返してゴールマスへ行くことです。 ただし、障害物マスやグリッドの外に移動することはできず、また縦移動と横移動を 1 回ずつ交互に行わなければなりません。（最初の移動の向きは任意です。）

ゴールマスへ行くことが可能であるか判定し、可能ならば移動回数の最小値を求めてください。

より形式的には、以下の条件をすべて満たすマスの列 (i 
1
​	
 ,j 
1
​	
 ),(i 
2
​	
 ,j 
2
​	
 ),…,(i 
k
​	
 ,j 
k
​	
 ) が存在するか判定し、存在するならば k−1 の最小値を求めてください。

すべての 1≤l≤k について、1≤i 
l
​	
 ≤H かつ 1≤j 
l
​	
 ≤W であり、(i 
l
​	
 ,j 
l
​	
 ) は障害物マスでない
(i 
1
​	
 ,j 
1
​	
 ) はスタートマス
(i 
k
​	
 ,j 
k
​	
 ) はゴールマス
すべての 1≤l≤k−1 について、∣i 
l
​	
 −i 
l+1
​	
 ∣+∣j 
l
​	
 −j 
l+1
​	
 ∣=1
すべての 1≤l≤k−2 について、i 
l
​	
 

=i 
l+1
​	
  ならば i 
l+1
​	
 =i 
l+2
​	
 
すべての 1≤l≤k−2 について、j 
l
​	
 

=j 
l+1
​	
  ならば j 
l+1
​	
 =j 
l+2
​	
 
制約
1≤H,W≤1000
H,W は整数
S 
i
​	
  は S, G, ., # からなる長さ W の文字列
スタートマスとゴールマスはちょうど 1 つずつ存在する
入力
入力は以下の形式で標準入力から与えられる。

H W
S 
1
​	
 
S 
2
​	
 
⋮
S 
H
​	
 
出力
ゴールマスへ行くことが可能ならば移動回数の最小値を、不可能ならば -1 を出力せよ。

入力例 1
Copy
3 5
.S#.G
.....
.#...
出力例 1
Copy
7


左図のように (1,2)→(2,2)→(2,3)→(3,3)→(3,4)→(2,4)→(2,5)→(1,5) と移動することで、7 回の移動でゴールマスへ行くことができます。 6 回以下の移動でゴールマスへ行くことはできないので、答えは 7 です。

右図のように横移動を連続で行う経路（あるいは縦移動を連続で行う経路）はとれないことに注意してください。

入力例 2
Copy
3 5
..#.G
.....
S#...
出力例 2
Copy
-1
ゴールマスへ行くことはできません。

入力例 3
Copy
8 63
...............................................................
..S...#............................#####..#####..#####..####G..
..#...#................................#..#...#......#..#......
..#####..####...####..####..#..#...#####..#...#..#####..#####..
..#...#..#..#...#..#..#..#..#..#...#......#...#..#..........#..
..#...#..#####..####..####..####...#####..#####..#####..#####..
................#.....#........#...............................
................#.....#........#...............................
出力例 3
Copy
148
"""

from collections import deque

# グリッドの高さ h、幅 w
h, w = map(int, input().split())

# グリッド本体（文字列の配列）
s = [input() for _ in range(h)]

# スタート(S)・ゴール(G)の座標
sx, sy, gx, gy = 0, 0, 0, 0
for i in range(h):
    for j in range(w):
        if s[i][j] == "S":
            sx, sy = i, j
        if s[i][j] == "G":
            gx, gy = i, j

# 無限大（未到達を表すため）
INF = float("inf")

# dist[x][y][0] : (x,y) に「直前が縦移動」で来たときの最短距離
# dist[x][y][1] : (x,y) に「直前が横移動」で来たときの最短距離
# 同じマスでも直前の移動方向が違えば別状態
dist = [[[INF] * 2 for _ in range(w)] for _ in range(h)]

# BFS用キュー
q = deque()

# 初期状態をキューに入れる
# (x, y, 現在までの距離, 直前の移動方向)
# arr = -1 は「まだ移動していない」ことを表す
q.append((sx, sy, 0, -1))

while q:
    # キューから状態を取り出す
    x, y, d_i, arr = q.popleft()

    # 直前が「縦移動」でない場合（= 横移動が可能）
    # arr == 0 は「直前が縦移動」
    if arr != 0:
        # 上下方向（縦移動）
        for i, j in [(x + 1, y), (x - 1, y)]:
            # グリッド内・障害物でない・より短く更新できる場合
            if 0 <= i < h and 0 <= j < w and s[i][j] != "#" and dist[i][j][0] > d_i + 1:
                # 直前を「縦移動(0)」として距離更新
                dist[i][j][0] = d_i + 1
                # 次の探索状態をキューに追加
                q.append([i, j, d_i + 1, 0])

    # 直前が「横移動」でない場合（= 縦移動が可能）
    # arr == 1 は「直前が横移動」
    if arr != 1:
        # 左右方向（横移動）
        for i, j in [(x, y + 1), (x, y - 1)]:
            # グリッド内・障害物でない・より短く更新できる場合
            if 0 <= i < h and 0 <= j < w and s[i][j] != "#" and dist[i][j][1] > d_i + 1:
                # 直前を「横移動(1)」として距離更新
                dist[i][j][1] = d_i + 1
                # 次の探索状態をキューに追加
                q.append([i, j, d_i + 1, 1])

# ゴールに到達したときの
# 「直前が縦」「直前が横」どちらの最短距離も考慮する
# 両方 INF なら到達不可
print(-1 if min(dist[gx][gy]) >= INF else min(dist[gx][gy]))
