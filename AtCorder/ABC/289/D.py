"""
AtCorder.ABC.289.D の Docstring
無限に続く階段があります。 一番下は 0 段目で、1 段のぼるごとに 1 段目、2 段目と続きます。

0 段目に階段登りロボットがいます。 階段登りロボットは、一回の動作で A 
1
​	
 ,A 
2
​	
 ,…,A 
N
​	
  段ぶん階段をのぼることができます。 つまり、階段登りロボットが i 段目にいるとき、一回動作をした後は i+A 
1
​	
  段目、i+A 
2
​	
  段目、⋯、i+A 
N
​	
  段目のいずれかにいることができます。 それ以外の段数を一回の動作でのぼることはできません。 階段登りロボットは階段を下ることもできません。

階段の B 
1
​	
 ,B 
2
​	
 ,…,B 
M
​	
  段目にはモチが設置されています。 モチが設置されている段へのぼるとロボットは動けなくなり、他の段に移動することができなくなります。

階段登りロボットは階段のちょうど X 段目にのぼりたいです。 階段登りロボットが階段のちょうど X 段目にのぼることが可能か判定してください。

制約
1≤N≤10
1≤A 
1
​	
 <A 
2
​	
 <⋯<A 
N
​	
 ≤10 
5
 
1≤M≤10 
5
 
1≤B 
1
​	
 <B 
2
​	
 <⋯<B 
M
​	
 <X≤10 
5
 
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N
A 
1
​	
  A 
2
​	
  … A 
N
​	
 
M
B 
1
​	
  B 
2
​	
  … B 
M
​	
 
X
出力
階段登りロボットが階段のちょうど X 段目にのぼることができるとき Yes を、そうでないとき No を 1 行に出力せよ。

入力例 1
Copy
3
3 4 5
4
4 5 6 8
15
出力例 1
Copy
Yes
例えば、次のようにして 15 段目に到達することができます。

階段を 3 段のぼる。ロボットは 3 段目に移動する。
階段を 4 段のぼる。ロボットは 7 段目に移動する。
階段を 5 段のぼる。ロボットは 12 段目に移動する。
階段を 3 段のぼる。ロボットは 15 段目に移動する。
入力例 2
Copy
4
2 3 4 5
4
3 4 5 6
8
出力例 2
Copy
No
どのように移動しても階段登りロボットが階段のちょうど 8 段目にいることはできません。

入力例 3
Copy
4
2 5 7 8
5
2 9 10 11 19
20
出力例 3
Copy
Yes
"""
N = int(input())
A = list(map(int,input().split()))
M = int(input())
B =set(map(int,input().split()))
X = int(input())

#dp[a]でaマス目に到達可能かを知る
dp = [False] * (X+1)
dp[0] = True  #今いるスタート地点

for i in range(X+1):
    if not dp[i]:
        continue 
    
    for a in A:
        nxt = i + a 
        if nxt <= X and nxt not in B:
            dp[nxt] = True 

if dp[X]:
    print("Yes")
else:
    print("No")