"""
AtCorder.ABC.441.D の Docstring
 頂点 M 辺の（単純とは限らない）有向グラフがあり、頂点は頂点 1,2,…,N と番号付けられています。
i 番目 (1≤i≤M) の辺は頂点 U 
i
​	
  から頂点 V 
i
​	
  へ向かう辺で、コストは C 
i
​	
  です。 また、各頂点の出次数は 4 以下です。

次の条件をみたす頂点 v (1≤v≤N) をすべて求めてください。

頂点 1 から頂点 v への経路であって、次の条件をともにみたすものが存在する。

ちょうど L 回辺を通る。このとき、同じ辺を複数回通っても良いが、通るたびに回数にカウントされる。
通った辺のコストの総和が S 以上 T 以下である。（同じ辺を複数回通った場合、通るたびに総和に加算されるものとする。）
出次数 とは
制約
1≤N≤2×10 
5
 
1≤M≤2×10 
5
 
1≤L≤10
1≤S≤T≤10 
9
 
1≤U 
i
​	
 ,V 
i
​	
 ≤N
1≤C 
i
​	
 ≤10 
8
 
各頂点の出次数は高々 4 である。
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N M L S T
U 
1
​	
  V 
1
​	
  C 
1
​	
 
U 
2
​	
  V 
2
​	
  C 
2
​	
 
⋮
U 
M
​	
  V 
M
​	
  C 
M
​	
 
出力
条件をみたす頂点を 昇順に 空白区切りで出力せよ。
条件をみたす頂点が存在しない場合は空行を出力せよ。

入力例 1
Copy
5 8 3 80 100
1 2 20
1 3 70
2 1 30
2 5 10
3 2 10
3 4 30
3 5 20
5 1 70
出力例 1
Copy
1 5
与えられるグラフは下図左のようになっています。各辺のコストはその辺の始点のそばに示されています。



このとき、以下のようになります。

頂点 1 から頂点 1 への経路について、頂点 1 → 頂点 2 → 頂点 5 → 頂点 1 （上図中央）を考えると、これはちょうど 3 本の辺を通り、通る辺のコストの総和は 20+10+70=100 であるため、条件をみたしています。
頂点 1 から頂点 2 への経路であって、条件をみたすような経路は存在しません。ちょうど 3 本の辺を通るような経路としては、頂点 1 → 頂点 2 → 頂点 1 → 頂点 2 が存在しますが、この経路において通る辺のコストの総和は 20+30+20=70 であり特に 80 より小さいため、条件をみたしていません。
頂点 1 から頂点 3 への経路であって、条件をみたすような経路は存在しません。ちょうど 3 本の辺を通るような経路としては、頂点 1 → 頂点 2 → 頂点 1 → 頂点 3 が存在しますが、この経路において通る辺のコストの総和は 20+30+70=120 であり特に 100 より大きいため、条件をみたしていません。
頂点 1 から頂点 4 への経路であって、条件をみたすような経路は存在しません。
頂点 1 から頂点 5 への経路について、頂点 1 → 頂点 3 → 頂点 2 → 頂点 5 （上図右）を考えると、これはちょうど 3 本の辺を通り、通る辺のコストの総和は 70+10+10=90 であるため、条件をみたしています。
よって、1, 5 をこの順に出力します。条件をみたす頂点を昇順に出力する必要があることに注意してください。

入力例 2
Copy
10 1 1 1 100
2 3 1
出力例 2
Copy

条件をみたす頂点が存在しない場合は空行を出力してください。

入力例 3
Copy
2 5 3 1 100
1 1 1
2 2 100
1 2 1
1 2 1
1 2 100
出力例 3
Copy
1 2
グラフは自己ループや多重辺を含む可能性があります。
なお、このテストケースにおけるグラフの頂点 1,2 からの出次数はそれぞれ 4,1 です。
"""
import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

N, M, L, S, T = map(int, input().split())
graph = [[] for _ in range(N)]
for _ in range(M):
    u, v, c = map(int, input().split())
    graph[u-1].append((v-1, c))

ok = [False]*N

def dfs(v, d, tot):#今いる頂点v,ここまでに使った辺の数,ここまでのコストの合計
    if d == L:
        if S <= tot <= T:
            ok[v] = True
        return
    for nv, cost in graph[v]:
        dfs(nv, d+1, tot+cost)

dfs(0, 0, 0)

ans = [str(i+1) for i in range(N) if ok[i]]
print(" ".join(ans))
