"""
AtCorder.ABC.429.D の Docstring
1 周の長さが M である池があり、その周上に 1 つの小屋と N 人の人が立っています。
実数 x (0≤x<M) について、小屋から時計回りに x だけ進んだところを地点 x と定義します。
i 番目の人は、 地点 A 
i
​	
  にいます。 複数の人が同じ場所に立っていることもあります。

また、N 以下の整数 C が与えられます。 i=0,1,…,M−1 について、X 
i
​	
  を次のように定義します。

高橋君は地点 (i+0.5) からスタートして、時計回りに動き始める。
高橋君は出会った人数の合計が C 未満である限り（時計回りに）動き続け、C 以上になったら止まる。ここで、「地点 y にいる人と出会う」とは、高橋君が地点 y に到達することを指す。
高橋君が止まるまでに出会った人数を X 
i
​	
  とする。ここで、高橋君が止まった地点に複数の人がいる場合、そこにいた人はすべて出会った人として数えられ、特に X 
i
​	
  は C より大きくなる可能性がある。
i=0,1,…,M−1 にわたる X 
i
​	
  の総和、すなわち  
i=0
∑
M−1
​	
 X 
i
​	
  を求めてください。

制約
1≤N≤5×10 
5
 
1≤M≤10 
12
 
0≤A 
i
​	
 ≤M−1
1≤C≤N
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N M C
A 
1
​	
  A 
2
​	
  … A 
N
​	
 
出力
i=0,1,…,M−1 にわたる X 
i
​	
  の総和を一行に出力せよ。

入力例 1
Copy
5 3 2
1 2 1 0 1
出力例 1
Copy
9
i=0 のとき、高橋君は地点 0.5 からスタートして時計回りに動きます。その後、次のようになります。

地点 1 で 1,3,5 番目の 3 人と出会い、今まで出会った人数の合計は 3 となる。これは C=2 以上であるため、高橋くんはそこで止まる。よって、X 
0
​	
 =3 である。
i=1 のとき、高橋君は地点 1.5 からスタートして時計回りに動きます。その後、次のようになります。

地点 2 で 2 番目の人と出会う。今まで出会った人数の合計は 1 であるため、動き続ける。
地点 0 で 4 番目の人と出会い、今まで出会った人数の合計は 2 となる。これは C=2 以上であるため、高橋くんはそこで止まる。よって、X 
1
​	
 =2 である。
i=2 のとき、高橋君は地点 2.5 からスタートして時計回りに動きます。その後、次のようになります。

地点 0 で 4 番目の人と会う。今まで出会った人数の合計は 1 であるため、動き続ける。
地点 1 で 1,3,5 番目の 3 人と会い、今まで出会った人数の合計は 4 となる。これは C=2 以上であるため、高橋くんはそこで止まる。よって、X 
2
​	
 =4 である。
よって、答えは X 
0
​	
 +X 
1
​	
 +X 
2
​	
 =3+2+4=9 となります。

入力例 2
Copy
1 1000000000000 1
1
出力例 2
Copy
1000000000000
高橋君はスタートする位置によらず、池の周りに立っている唯一の人である、地点 1 にいる人に出会った時に止まります。
よって、i によらず X 
i
​	
 =1 であり、答えは 10 
12
  となります。
"""
N, M, C = map(int, input().split())
A = list(map(int, input().split()))

# 人の位置をソート
A.sort()

# 同じ位置ごとにまとめる
b = []  # 人がいる地点
p = []  # その地点にいる人数

i = 0
while i < N:
    x = A[i]
    j = i + 1
    while j < N and A[j] == x:
        j += 1
    b.append(x)
    p.append(j - i)
    i = j

k = len(b)

# 尺取り法（円環）
r = 0
cur = 0   # 今までに出会った人数
ans = 0

for i in range(k):
    # cur >= C になるまで r を進める
    while cur < C:
        cur += p[r]
        r += 1
        if r == k:
            r = 0

    # 区間の長さを計算
    if i == 0:
        length = M + b[0] - b[k - 1]
    else:
        length = b[i] - b[i - 1]

    # この区間のスタート位置すべてで X_i = cur
    ans += length * cur

    # 次に進むので左端を外す
    cur -= p[i]

print(ans)
