""""
N 頂点 M 辺の単純連結無向グラフ G が与えられます。
G の頂点および辺はそれぞれ頂点 1,2,…,N、辺 1,2,…,M と番号づけられており、 辺 i は頂点 U 
i
​	
  と頂点 V 
i
​	
  を結んでいます。
辺で結ばれている頂点の間は双方向に時間 1 で移動することができます。

また、各頂点は安全か危険かのどちらかであり、その状態は S と D のみからなる長さ N の文字列 S によって与えられます。
具体的には、S の i 文字目 (1≤i≤N) が S のとき頂点 i は安全であり、D のとき頂点 i は危険です。
ここで、安全な頂点が 2 つ以上、危険な頂点が 1 つ以上あることが保証されます。

危険な頂点 v それぞれについて、次の値を求めてください。

ある安全な頂点から出発し、v を経由し、 出発した頂点と異なる 安全な頂点へ移動するのにかかる時間としてあり得る最小値
制約
3≤N≤2×10 
5
 
N−1≤M≤2×10 
5
 
1≤U 
i
​	
 ,V 
i
​	
 ≤N
U 
i
​	
 

=V 
i
​	
 
i

=j ならば {U 
i
​	
 ,V 
i
​	
 }

={U 
j
​	
 ,V 
j
​	
 }
S は S と D のみからなる長さ N の文字列
N,M,U 
i
​	
 ,V 
i
​	
  はすべて整数
G は連結である。
安全な頂点が 2 つ以上存在する。
危険な頂点が 1 つ以上存在する。
入力
入力は以下の形式で標準入力から与えられる。

N M
U 
1
​	
  V 
1
​	
 
U 
2
​	
  V 
2
​	
 
⋮
U 
M
​	
  V 
M
​	
 
S
出力
G 上の危険な頂点の個数を K として、K 行出力せよ。
i 行目 (1≤i≤K) には、危険な頂点を頂点番号の昇順に並べた時に i 番目に来る頂点についての答えを出力せよ。

入力例 1
Copy
5 5
1 2
1 3
2 3
3 4
4 5
SSDDS
出力例 1
Copy
2
3
危険な頂点は（頂点番号について昇順に）頂点 3 と 4 です。

頂点 3 については、頂点 1 → 頂点 3 → 頂点 2 と移動するときなどが条件をみたします。
この移動にかかる時間は 2 であり、このときが最小です。
よって、1 行目に 2 を出力します。

頂点 4 については、頂点 1 → 頂点 3 → 頂点 4 → 頂点 5 と移動するときなどが条件をみたします。
この移動にかかる時間は 3 であり、かかる時間が 2 以下の条件をみたす移動方法がないため、このときが最小です。
よって、2 行目に 3 を出力します。

入力例 2
Copy
3 2
1 2
2 3
SSD
出力例 2
Copy
3
危険な頂点は頂点 3 です。

頂点 1 → 頂点 2 → 頂点 3 → 頂点 2 と移動するときなどが条件をみたします。
この移動にかかる時間は 3 であり、このときが最小です。
頂点 2 → 頂点 3 → 頂点 2 などの移動は、「出発した頂点と異なる」という条件をみたしていないことに注意してください。
危険な頂点 V に対して、安全な頂点のうちその頂点から近い（必要な移動時間が短い）方から順に 2 つを U,U 
′
  とすると、求めたい値は U から V への移動時間と U 
′
  から V への移動時間の総和と等しくなります。これは、U→V→U 
′
  という移動が条件をみたしているため求める値はそれ以下であり、それ未満の移動方法が存在する時、U,U 
′
  が近い方から 2 つという条件に反することから従います。

よって、すべての頂点 V について、安全な頂点のうち近い方から 2 つと、それらの頂点から V へ の必要な移動時間（以下、距離とします）がわかれば良いです。 すべての辺の重み（移動時間）は 1 であるため、幅優先探索 (BFS) で求めることができますが、通常の探索と比較して次の 2 点に注意する必要があります。

始点の候補が複数存在する。
各頂点について、始点からの最短距離だけではなく、2 番目に近い頂点からの距離も記録する必要がある。
1 つめについては、例えば、もう 1 つ別の頂点が存在し（超頂点）が存在し、そこからすべての安全な頂点へ重み 0 の辺が伸びていると考えることができます。実装方針によっては、単に BFS で最初に調べる頂点を複数に変更するだけで良いこともあります。
2 つめについては、BFS における、「一度到達（探索）した頂点は再び調べない。」という条件を「2 つの異なる頂点から到達（探索）した頂点はそれ以降調べない。」という条件に書き換えれば良いです。よって、各頂点ごとに訪ねたことがあるか無いかを管理（更新）する代わりに、「どの始点からも訪ねられたことがない」、「頂点 u からのみ訪ねられた」、「2 つ以上の始点から訪ねられたことがある」のいずれの状態であるかを管理するようにすれば良いです。 また、このとき、BFS において（キューなどで）管理する情報として、「到達した頂点」と「始点からその頂点までの距離」に加えて、「始点」（どの安全な頂点を始点とした経路か）の情報も必要になることに注意してください。

このようにして、すべての頂点 V について、安全な頂点のうち近い方から 2 つと、それらの頂点から V へ の距離が求まれば、特に危険な頂点について 2 つの距離の総和として答えを求めることができます。
必要な時間計算量は O(N+M) であり、十分高速です。よって、この問題を解くことができました。

c++ による実装例:

Copy
#include <bits/stdc++.h>
using namespace std;
#define rep(i, n) for(int i = 0; i < n; ++i)
struct path_info{
	int from,to;
	int dist;
};
int main() {
	int n,m,u,v;
	string s;
	
	cin>>n>>m;
	vector<vector<int> >e(n);
	vector<vector<int> >f(n,vector<int>(2,-1));
	vector<vector<int> >d(n,vector<int>(2,-1));
	queue<path_info>q;
	rep(i,m){
		cin>>u>>v;
		e[u-1].push_back(v-1);
		e[v-1].push_back(u-1);
	}
	cin>>s;
	rep(i,n){
		if(s[i]=='S'){
			f[i][0]=i;
			d[i][0]=0;
			q.push({i,i,0});
		}
	}
	while(!q.empty()){
		path_info tmp=q.front();
		q.pop();
		int u=tmp.from;
		int v=tmp.to;
		int sz=e[v].size();
		rep(i,sz){
			if(f[e[v][i]][0]==-1){
				f[e[v][i]][0]=u;
				d[e[v][i]][0]=tmp.dist+1;
				q.push({u,e[v][i],tmp.dist+1});
			}
			else if((f[e[v][i]][1]==-1)&&(f[e[v][i]][0]!=u)){
				f[e[v][i]][1]=u;
				d[e[v][i]][1]=tmp.dist+1;
				q.push({u,e[v][i],tmp.dist+1});
			}
		}
	}
	rep(i,n){
		if(s[i]=='D')cout<<(d[i][0]+d[i][1])<<endl;
	}
	return 0;
}
"""
from collections import deque

# 入力
N, M = map(int, input().split())
edges = [[] for _ in range(N)]

for _ in range(M):
    u, v = map(int, input().split())
    u -= 1
    v -= 1
    edges[u].append(v)
    edges[v].append(u)

S = input().strip()

# f[v][0], f[v][1] : v に到達した安全頂点（始点）
# d[v][0], d[v][1] : その距離
f = [[-1, -1] for _ in range(N)]
d = [[-1, -1] for _ in range(N)]

# BFSキュー: (始点, 現在頂点, 距離)
q = deque()

# 安全頂点をすべて始点として初期化
for i in range(N):
    if S[i] == 'S':
        f[i][0] = i
        d[i][0] = 0
        q.append((i, i, 0))

# BFS
while q:
    start, v, dist = q.popleft()
    for nv in edges[v]:
        # まだ誰からも到達していない
        if f[nv][0] == -1:
            f[nv][0] = start
            d[nv][0] = dist + 1
            q.append((start, nv, dist + 1))
        # 2人目として到達（始点が異なる）
        elif f[nv][1] == -1 and f[nv][0] != start:
            f[nv][1] = start
            d[nv][1] = dist + 1
            q.append((start, nv, dist + 1))

# 出力（危険頂点を番号順）
for i in range(N):
    if S[i] == 'D':
        print(d[i][0] + d[i][1])
