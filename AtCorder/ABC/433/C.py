"""
AtCorder.ABC.433.C の Docstring
数字からなる文字列 S が与えられます。

以下の条件を全て満たす文字列 T を 1122文字列 と呼びます。（定義は F 問題と同じです。）

T は数字からなる空でない文字列
∣T∣ は偶数。ここで、 ∣T∣ は文字列 T の長さを表す
T の 1 文字目から  
2
∣T∣
​	
  文字目までは全て同じ数字である
T の  
2
∣T∣
​	
 +1 文字目から ∣T∣ 文字目までは全て同じ数字である
T の 1 文字目の数字に 1 を足すと ∣T∣ 文字目の数字になる
例えば 1122 や 01 、 444555 などは 1122文字列 ですが、 1222 や 90 は 1122文字列 ではありません。

S の 部分文字列 であって 1122文字列 であるものの個数を求めてください。

ただし、ある二つの部分文字列が文字列として同じでも、取り出された位置が異なるならばそれらは別々に数えるものとします。

制約
S は長さ 1 以上 10 
6
  以下の数字からなる文字列
入力
入力は以下の形式で標準入力から与えられる。

S
出力
S の空でない部分文字列であって 1122文字列 であるものの個数を出力せよ。

入力例 1
Copy
1122
出力例 1
Copy
2
以下の 2 つの部分文字列が条件を満たします。

S の 2 文字目から 3 文字目を取り出した 12
S の 1 文字目から 4 文字目を取り出した 1122
したがって、 2 を出力してください。

入力例 2
Copy
7788788
出力例 2
Copy
3
文字列として同じでも、取り出された位置が異なるならばそれらは別々に数えることに注意してください。

入力例 3
Copy
2025
出力例 3
Copy
0
1122文字列 となる部分文字列が存在しない場合もあります。

入力例 4
Copy
1112222334445556555
出力例 4
Copy
11
"""
S = input()

# RLE
runs = []#："111222" → [(1,3), (2,3)]
i = 0
n = len(S)

while i < n:
    j = i#終点
    while j < n and S[j] == S[i]:
        j += 1
    runs.append((int(S[i]), j - i))#int(S[i])：塊の数字（文字→整数にしてる）,j - i =>：S="111222" で最初の塊なら i=0, j=3 → 長さ 3
    i = j #i〜j-1 だったから、次は j から始まる。

ans = 0
for i in range(len(runs) - 1):
    a, la = runs[i]#runs[i]=(1,3) → a=1, la=3
    b, lb = runs[i+1]# 同様に取り出す
    if b == a + 1:#つまり 塊が「1の塊の次が2の塊」みたいになってるかをチェック。
        ans += min(la, lb)
        """
        例1
111222
la = 3
lb = 3
作れる部分文字列：
k	部分文字列
1	12
2	1122
3	111222
👉 3個 = min(3,3)
        """
print(ans)

    
    