"""
AtCorder.ABC.431.D の Docstring
問題文
頭と体からなるロボットがあります。 このロボットには、同時に取り付けられる部品が種類 1, 種類 2,…, 種類 N の N 種類あります。 種類 i (1≤i≤N) の部品の重さは W 
i
​	
  です。 それぞれの部品には、頭に取り付けたときと体に取り付けたときで異なる嬉しさがあります。 種類 i (1≤i≤N) の部品を頭に取り付けたときの嬉しさは H 
i
​	
  、体に取り付けたときの嬉しさは B 
i
​	
  です。

ロボットは頭の重さが体の重さより大きいと倒れてしまいます。 ここで、頭の重さおよび体の重さはそれぞれ頭もしくは体に取り付けられた部品の重さの合計とします。

高橋くんは、N 種類の部品をすべて 1 個ずつロボットに取り付けたいと思っています。 ロボットを倒さないように部品を取り付けたときの、すべての部品の嬉しさの合計としてありえる最大値を求めてください。

制約
1≤N≤500
1≤W 
i
​	
 ≤500 (1≤i≤N)
1≤H 
i
​	
 ≤10 
9
  (1≤i≤N)
1≤B 
i
​	
 ≤10 
9
  (1≤i≤N)
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N
W 
1
​	
  H 
1
​	
  B 
1
​	
 
W 
2
​	
  H 
2
​	
  B 
2
​	
 
⋮
W 
N
​	
  H 
N
​	
  B 
N
​	
 
出力
ロボットを倒さないように部品を取り付けたときの、すべての部品の嬉しさの合計としてありえる最大値を出力せよ。

入力例 1
Copy
3
1 41 59
2 65 35
8 97 93
出力例 1
Copy
217
種類 1 と種類 3 の部品を体に、種類 2 の部品を頭に取り付けることで、ロボットを倒さないようにしつつ嬉しさの合計を 217 にすることができます。

ロボットを倒さないように部品を取り付けて嬉しさの合計を 218 以上にすることはできないため、217 を出力してください。

入力例 2
Copy
1
1 1000000000 1
出力例 2
Copy
1
唯一の部品を体に取り付けないとロボットは倒れてしまいます。 頭にひとつも部品を取り付けなくてもよいことに注意してください。

入力例 3
Copy
2
1 1000000000 1
1 1 1000000000
出力例 3
Copy
2000000000
頭の重さと体の重さが等しい場合、ロボットは倒れないことに注意してください。

入力例 4
Copy
20
483 984529882 299667119
372 428935469 104847758
467 709733529 102461200
421 659244277 110859936
231 786224280 773073478
351 334234040 193222121
119 404159408 772024933
302 519596088 432627257
433 910226244 337833733
184 406236461 530198622
335 465203041 353047747
418 656273464 114923636
482 972364803 329650748
453 748321854 169441643
105 138464898 587159653
401 832952051 506021805
403 810916971 468755944
231 798801044 749313343
292 631278033 556088607
366 567211596 374825770
出力例 4
Copy
12091388792
答えが 2 
32
  を超える場合があることに注意してください。
"""
N = int(input())
parts = []
sumW = 0
for _ in range(N):
    w,h,b = map(int,input().split())
    parts.append((w,h,b))
    sumW += w
    
#dp[d]:重さ差が(d-offset)の時の最大嬉しさ
offset = sumW
INF =  -10**30

dp = [INF] * (2 * sumW +1)
dp[offset] = 0 #差0
for w,h,b in parts:
    ndp = [INF] * (2 * sumW + 1)
    for d in range(2 * sumW + 1):
        if dp[d] == INF:
            continue
        
        #頭につける(差-w)
        if 0 <= d-w <= 2*sumW:
            ndp[d-w] = max(ndp[d-w],dp[d]+h)
        #体につける(差+w)
        if 0 <= d + w <= 2 * sumW:
            ndp[d+w] = max(ndp[d+w],dp[d]+b)
            
    dp = ndp
    
ans = max(dp[offset:])
print(ans)