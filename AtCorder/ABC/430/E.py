"""
AtCorder.ABC.430.E の Docstring
 1 からなる長さの等しい文字列 A,B が与えられます。

A に対して以下の操作を 0 回以上何度でも行うことができます。

A の先頭の文字を末尾に移動させる。
A=B とするために必要な最小の操作回数を求めてください。
但し、どのように操作しても A=B とできない場合、代わりに −1 と出力してください。

T 個のテストケースが与えられるので、それぞれについて答えを求めてください。

制約
1≤T≤10000
A,B は 0, 1 からなる文字列
2≤∣A∣=∣B∣≤10 
6
 
ひとつの入力について、 ∣A∣ の総和は 10 
6
  を超えない
入力
入力は以下の形式で標準入力から与えられる。

T
case 
1
​	
 
case 
2
​	
 
⋮
case 
T
​	
 
各テストケースは以下の形式で与えられる。

A
B
出力
T 行出力せよ。

i 行目には i 番目のテストケースについて、答えを出力せよ。

入力例 1
Copy
5
1010001
1000110
000
111
01010
01010
0101
0011
100001101110000001010110110001
101100011000011011100000010101
出力例 1
Copy
2
-1
0
-1
22
この入力には 5 個のテストケースが含まれます。

1 番目のテストケースについて、 A= 1010001 、 B= 1000110 です。
A に操作を 2 回行うと A が 1010001 → 0100011 → 1000110 となり、 A=B とできます。
2 番目のテストケースについて、どのように操作を行っても 000 を 111 にすることはできません。
3 番目のテストケースについて、はじめから A=B です。

"""
import sys
input = sys.stdin.readline

def z_algorithm(s: str):
    n = len(s)
    z = [0] * n
    z[0] = n
    l = r = 0
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    return z

T = int(input())
for _ in range(T):
    A = input().strip()
    B = input().strip()
    n = len(A)

    if n != len(B):
        print(-1)
        continue

    S = B + A + A
    z = z_algorithm(S)

    ans = -1
    for k in range(n):
        if z[n + k] >= n:
            ans = k
            break

    print(ans)
