"""
空の列 A があります。クエリが Q 個与えられるので、与えられた順番に処理してください。
クエリは次の 3 種類のいずれかです。

1 x : A の最後尾に x を追加する。
2 : A の最初の要素を出力する。その後、その要素を削除する。このクエリが与えられるとき、A は空でないことが保証される。
3 : A を昇順にソートする。
制約
1≤Q≤2×10 
5
 
0≤x≤10 
9
 
クエリ 2 が与えられるとき、A は空でない。
入力は全て整数である。
入力
入力は以下の形式で標準入力から与えられる。

Q
query1
query2
⋮
queryQ
i 番目のクエリ queryi では、まずクエリの種類 c 
i
​	
 （ 1,2,3 のいずれか）が与えられる。 c 
i
​	
 =1 の場合はさらに整数 x が追加で与えられる。

すなわち、各クエリは以下に示す 3 つの形式のいずれかである。

1 x
2
3
出力
c 
i
​	
 =2 を満たすクエリの回数を q として q 行出力せよ。
j (1≤j≤q) 行目では j 番目のそのようなクエリに対する答えを出力せよ。

入力例 1
Copy
8
1 4
1 3
1 2
1 1
3
2
1 0
2
出力例 1
Copy
1
2
入力例 1 において、 i 番目のクエリを処理した後の A の状態を i 行目に示すと以下のようになります。

(4)
(4,3)
(4,3,2)
(4,3,2,1)
(1,2,3,4)
(2,3,4)
(2,3,4,0)
(3,4,0)
入力例 2
Copy
9
1 5
1 5
1 3
2
3
2
1 6
3
2
出力例 2
Copy
5
3
5
入力例 2 において、 i 番目のクエリを処理した後の A の状態を i 行目に示すと以下のようになります。

(5)
(5,5)
(5,5,3)
(5,3)
(3,5)
(5)
(5,6)
(5,6)
(6)
"""
from collections import deque
import heapq 
Q = int(input())

queue = deque()#まだソートされない要素
heap = []#ソーto済み要素

for _ in range(Q):
    query = list(map(int,input().split()))
    #1x
    if query[0] == 1:
        queue.append(query[1])
    #2
    elif query[0] == 2:
        if heap:
            print(heap.heappop(heap))
        else:
            print(queue.popleft())
    #3
    else:
        while queue:
            heapq.heappush(heap,queue.popleft())
