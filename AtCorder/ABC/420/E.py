"""
AtCorder.ABC.420.E の Docstring
問題文
N 頂点 0 辺の無向グラフが与えられます。
頂点には 1,2,…,N の番号が付けられており、最初は全ての頂点が白色です。
以下の 3 種類のクエリを合計 Q 個処理して下さい。

タイプ 1 : 頂点 u,v を結ぶ無向辺を追加する。
タイプ 2 : 頂点 v が白色なら黒色に、黒色なら白色に変更する。
タイプ 3 : 頂点 v から 0 本以上の辺を辿って黒色の頂点に到達できるか判定し、到達できるなら Yes 、到達できないなら No と答える。
制約
入力は全て整数
1≤N≤2×10 
5
 
1≤Q≤6×10 
5
 
タイプ 1 のクエリは以下の制約を満たす。
1≤u<v≤N
各クエリについて、そのクエリより前に u,v を結ぶ辺は追加されていない。
タイプ 2,3 のクエリは以下の制約を満たす。
1≤v≤N
入力
入力は以下の形式で標準入力から与えられる。

N Q
Query 
1
​	
 
Query 
2
​	
 
⋮
Query 
Q
​	
 
但し、 Query 
i
​	
  は i 個目のクエリを表す。

タイプ 1 のクエリは以下の形式で与えられる。

1 u v
タイプ 2 のクエリは以下の形式で与えられる。

2 v
タイプ 3 のクエリは以下の形式で与えられる。

3 v
出力
タイプ 3 のクエリが現れる度に、その解答を次の通りに出力せよ。

頂点 v から 0 本以上の辺を辿って黒色の頂点に到達できるなら Yes
頂点 v から 0 本以上の辺を辿って黒色の頂点に到達できないなら No
入力例 1
Copy
5 12
3 2
2 2
3 2
1 2 5
1 3 4
3 4
3 5
1 4 5
1 1 3
3 1
2 2
3 1
出力例 1
Copy
No
Yes
No
Yes
Yes
No
この入力では、グラフは最初 5 頂点 0 辺です。
この入力には 12 個のクエリが含まれます。

1 個目のクエリは 3 2 です。
この時点で頂点 2 から 0 本以上の辺を辿って黒色の頂点に到達できないので、 No と解答します。
2 個目のクエリは 2 2 です。
頂点 2 は白色なので、黒色に変更します。
3 個目のクエリは 3 2 です。
この時点で頂点 2 から 0 本以上の辺を辿って黒色の頂点 2 に到達できます。よって、 Yes と解答します。
4 個目のクエリは 1 2 5 です。
頂点 2,5 を結ぶ辺を追加します。
5 個目のクエリは 1 3 4 です。
頂点 3,4 を結ぶ辺を追加します。
6 個目のクエリは 3 4 です。
この時点で頂点 4 から 0 本以上の辺を辿って黒色の頂点に到達できないので、 No と解答します。
7 個目のクエリは 3 5 です。
この時点で頂点 5 から 0 本以上の辺を辿って黒色の頂点 2 に到達できます。よって、 Yes と解答します。
8 個目のクエリは 1 4 5 です。
頂点 4,5 を結ぶ辺を追加します。
9 個目のクエリは 1 1 3 です。
頂点 1,3 を結ぶ辺を追加します。
10 個目のクエリは 3 1 です。
この時点で頂点 1 から 0 本以上の辺を辿って黒色の頂点 2 に到達できます。よって、 Yes と解答します。
11 個目のクエリは 2 2 です。
頂点 2 は黒色なので、白色に変更します。
12 個目のクエリは 3 1 です。
この時点で頂点 1 から 0 本以上の辺を辿って黒色の頂点に到達できないので、 No と解答します。

"""
import sys
sys.setrecursionlimit(10**7)
input = sys.stdin.readline

N, Q = map(int, input().split())

# Union-Find
parent = list(range(N))
size = [1] * N

# 各連結成分に含まれる黒頂点の数
black_cnt = [0] * N

# 各頂点の色（False = 白, True = 黒）
is_black = [False] * N


def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]


def union(x, y):
    x = find(x)
    y = find(y)
    if x == y:
        return
    if size[x] < size[y]:
        x, y = y, x
    parent[y] = x
    size[x] += size[y]
    black_cnt[x] += black_cnt[y]


for _ in range(Q):
    q = list(map(int, input().split()))

    if q[0] == 1:
        _, u, v = q
        union(u - 1, v - 1)

    elif q[0] == 2:
        _, v = q
        v -= 1
        root = find(v)
        if is_black[v]:
            is_black[v] = False
            black_cnt[root] -= 1
        else:
            is_black[v] = True
            black_cnt[root] += 1

    else:
        _, v = q
        v -= 1
        root = find(v)
        if black_cnt[root] > 0:
            print("Yes")
        else:
            print("No")
