"""
AtCorder.ABC.088.D の Docstring
問題文
縦 H マス, 横 W マスに広がるマス目があり, 各マスは白または黒で塗られている. 上から i 番目で左から j 番目のマスを (i,j) で表す. すぬけ君は, このマス目を使って次のようなゲームをしたい. ゲームの開始時点ではマス (1,1) にゲームキャラクター「けぬす君」がいる. プレイヤーはけぬす君を上下左右の 4 方向のいずれかに 1 マスだけ動かすことを繰り返す. けぬす君が白いマスだけを通って (H,W) にたどり着けばゲームクリアとなる.
ゲームを開始する前に, すぬけ君はいくつかの白いマス目の色を黒に変えることができる. ただし, マス (1,1) と (H,W) の色を変えることはできず, ゲームを開始するまでにすべての色の変更を行わなければならない.
ゲームをクリアしたとき, ゲームの開始前にマスの色を変えた回数がすぬけ君のスコアとなる. そのとき, すぬけ君が取る可能性のある最大のスコアを求めなさい.ただし, すぬけ君がどのようにマス目の色を変えてもけぬす君が (H,W) にたどり着くことが出来ない場合、−1 と出力しなさい.

ただし, 各マスの色の情報は文字 s 
i,j
​	
  として与えられる. マス (i,j) が最初白で塗られている場合 s 
i,j
​	
  は . であり, マス (i,j) が最初黒で塗られている場合 s 
i,j
​	
  は # である.

制約
H は 2 以上 50 以下の整数
W は 2 以上 50 以下の整数
s 
i,j
​	
  は . または # (1≤i≤H,1≤j≤W)
s 
1,1
​	
 ,s 
H,W
​	
  は . である
入力
入力は以下の形式で標準入力から与えられる.

H W
s 
1,1
​	
 s 
1,2
​	
 s 
1,3
​	
 ...s 
1,W
​	
 
s 
2,1
​	
 s 
2,2
​	
 s 
2,3
​	
 ...s 
2,W
​	
 
 :   :
s 
H,1
​	
 s 
H,2
​	
 s 
H,3
​	
 ...s 
H,W
​	
 
出力
すぬけ君が取る可能性のある最大のスコアを出力しなさい. ただし, すぬけ君がどのようにマス目の色を変えてもけぬす君が (H,W) にたどり着くことが出来ない場合、−1 と出力しなさい.

入力例 1
Copy
3 3
..#
#..
...
出力例 1
Copy
2
下の図のようにマス目の色を変えれば, スコア 2 を達成できます.
Explanation of Sample 1

入力例 2
Copy
10 37
.....................................
...#...####...####..###...###...###..
..#.#..#...#.##....#...#.#...#.#...#.
..#.#..#...#.#.....#...#.#...#.#...#.
.#...#.#..##.#.....#...#.#.###.#.###.
.#####.####..#.....#...#..##....##...
.#...#.#...#.#.....#...#.#...#.#...#.
.#...#.#...#.##....#...#.#...#.#...#.
.#...#.####...####..###...###...###..
.....................................
出力例 2
Copy
209

"""
from collections import deque 
H,W = map(int,input().split())
S = [list(input()) for _ in range(H)]

dist = [[-1]*W for _ in range(H)]
# sx,sy = 0,0
# gx,gy = H-1,W-1

dirs = [(-1,0),(0,1),(1,0),(0,-1)]

def bfs():
  queue = deque()
  
  sx,sy = 0,0
  dist[sx][sy] = 1
  gx,gy = H-1,W-1 
  
  queue.append((sx,sy))
  
  while queue:
    x,y = queue.popleft()
    for dx,dy in dirs:
       nx,ny = x+dx,y+dy 
       if not (0<=nx<H and 0<= ny<W):
         continue 
       if S[nx][ny] == '#':
         continue 
       if dist[nx][ny] != -1:
         continue 
       dist[nx][ny] = dist[x][y] +1
       queue.append((nx,ny))

bfs()

tw = 0
#全白色のマスを出す
for row in S:
  tw +=row.count('.')
  
if dist[H-1][W-1] == -1:
  print(-1)
else:
  print(tw-dist[H-1][W-1])  