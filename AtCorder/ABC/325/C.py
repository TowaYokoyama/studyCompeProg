"""
AtCorder.ABC.325.C の Docstring
H 行 W 列のマス目の上に 0 個以上のセンサが配置されています。上から i 行目、左から j 列目のマス目を (i,j) と表記します。
センサが配置されているマス目の情報は長さ W の文字列 S 
1
​	
 ,S 
2
​	
 ,…,S 
H
​	
  によって与えられ、S 
i
​	
  の j 文字目が # のとき、またそのときに限り (i,j) にセンサが配置されています。
このセンサは上下左右斜めに隣接しているマス目に存在する他のセンサと連動し、一つのセンサとして動作します。 ただし、マス目 (x,y) と (x 
′
 ,y 
′
 ) が上下左右斜めに隣接しているとは、max(∣x−x 
′
 ∣,∣y−y 
′
 ∣)=1 であることを指します。
また、センサ A とセンサ B が連動し、センサ A とセンサ C が連動しているとき、センサ B とセンサ C も連動することに注意してください。

連動するセンサを一つのセンサと見なしたとき、このマス目の上にあるセンサの個数を求めてください。

制約
1≤H,W≤1000
H,W は整数
S 
i
​	
  は各文字が # または . である長さ W の文字列
入力
入力は以下の形式で標準入力から与えられる。

H W
S 
1
​	
 
S 
2
​	
 
⋮
S 
H
​	
 
出力
答えを出力せよ。

入力例 1
Copy
5 6
.##...
...#..
....##
#.#...
..#...
出力例 1
Copy
3
連動しているセンサを一つのセンサと見なしたとき、

(1,2),(1,3),(2,4),(3,5),(3,6) にあるセンサが連動したもの
(4,1) にあるセンサ
(4,3),(5,3) にあるセンサが連動したもの
の 3 つのセンサが存在します。

入力例 2
Copy
3 3
#.#
.#.
#.#
出力例 2
Copy
1
入力例 3
Copy
4 2
..
..
..
..
出力例 3
Copy
0
入力例 4
Copy
5 47
.#..#..#####..#...#..#####..#...#...###...#####
.#.#...#.......#.#...#......##..#..#...#..#....
.##....#####....#....#####..#.#.#..#......#####
.#.#...#........#....#......#..##..#...#..#....
.#..#..#####....#....#####..#...#...###...#####
出力例 4
Copy
7

"""
from collections import deque
H,W = map(int,input().split())
S = []
for _ in range(H):
    s = input()
    S.append(s)

visited = [[False]*W for _ in range(H)] 
dirs = [
    (-1,-1), (-1,0), (-1,1),
    ( 0,-1),         ( 0,1),
    ( 1,-1), ( 1,0), ( 1,1)
]

def bfs(sx,sy):
    queue = deque([(sx,sy)])
    visited[sx][sy] = True
    while queue:
        x, y = queue.popleft()
        for dx,dy in dirs:
            nx = x+dx 
            ny = y+dy
            if 0<=nx<H and 0<=ny<W: 
                if S[nx][ny] == '#' and not visited[nx][ny]:
                    visited[nx][ny] = True
                    queue.append((nx, ny))
                    
ans = 0
for i in range(H):
    for j in range(W):
        if S[i][j] == '#' and not visited[i][j]:
            bfs(i,j)
            ans+=1   
print(ans)