"""
AtCorder.ABC.443.E の Docstring
問題文
N×N のマス目があります。このマス目の上から i 行目、左から j 列目を (i,j) と呼びます。
マス目の情報は N 個の文字列 S 
1
​	
 ,S 
2
​	
 ,…,S 
N
​	
  として与えられ、 S 
i
​	
  の j 文字目が . のとき (i,j) は空きマス、 # のとき (i,j) は壁マスです。

はじめ、高橋君は空きマス (N,C) におり、以下の移動を N−1 回繰り返します。

現在高橋君が (r,c) にいるとき、 (r−1,c−1),(r−1,c),(r−1,c+1) のいずれかを移動先として指定する。但し、マス目中に存在しないマスを移動先として指定することはできない。
もし移動先 (a,b) が壁マスである場合、以下のことが起こる。
現時点で a<i≤N を満たす全ての整数について (i,b) が空きマスであった場合、 (a,b) にある壁を破壊し、移動する。すなわち、 (a,b) は空きマスになり、高橋君は (a,b) に移動する。
そうでない場合、高橋君は移動に失敗する。この場合、移動が N−1 回に満たなくとも直ちに移動の繰り返しを終了する。
もし移動先 (a,b) が空きマスである場合、高橋君は (a,b) に移動する。
以下の条件を満たす長さ N の文字列 R を出力してください。

もし移動中に失敗せず (1,i) に辿り着ける場合、 R の i 文字目は 1
そうでない場合、 R の i 文字目は 0
T 個のテストケースが与えられるので、それぞれについて答えを求めてください。

制約
T,N,C は整数
1≤T≤50000
2≤N≤3000
1≤C≤N
S 
i
​	
  は . と # からなる長さ N の文字列
S 
N
​	
  の C 文字目は .
ひとつの入力について、 N 
2
  の総和は 9×10 
6
  を超えない
入力
入力は以下の形式で標準入力から与えられる。

T
case 
1
​	
 
case 
2
​	
 
⋮
case 
T
​	
 
各テストケースは以下の形式で与えられる。

N C
S 
1
​	
 
S 
2
​	
 
⋮
S 
N
​	
 
出力
T 行出力せよ。

i 行目には i 番目のテストケースに対する答えを出力せよ。

入力例 1
Copy
5
5 3
.###.
..#..
#.#.#
#...#
##..#
2 2
##
..
4 1
####
####
####
.###
3 3
...
...
...
10 3
##.##.##.#
.####..#..
...#.#..#.
.#.#.#.#..
...####...
#.#.##....
.##...#...
#.##.....#
#....###.#
.#..#.#...
出力例 1
Copy
10111
11
1000
111
0011010010
この入力には 5 個のテストケースが含まれます。

1 番目のテストケースについて、例えば以下のようにして移動中に失敗せず (1,3) に辿り着くことができます。

はじめ、高橋君は (5,3) にいる。
空きマス (4,2) に移動する。
(3,3) は壁マスであるが、現時点で (4,3),(5,3) は共に空きマスであるため、高橋君は (3,3) にある壁を破壊して (3,3) に移動する。
(2,3) は壁マスであるが、現時点で (3,3),(4,3),(5,3) は共に空きマスであるため、高橋君は (2,3) にある壁を破壊して (2,3) に移動する。
(1,3) は壁マスであるが、現時点で (2,3),(3,3),(4,3),(5,3) は共に空きマスであるため、高橋君は (1,3) にある壁を破壊して (1,3) に移動する。
移動中に失敗せず (1,1),(1,3),(1,4),(1,5) には辿り着くことができるので、 10111 と出力してください。
"""
# from collections import deque
# T = int(input())
# for _ in range(T):
#     N,C = map(int,input().split())
#     grid = []
#     dirs = [(-1,-1),(-1,0),(-1,1)]
#     ans = []#最後に結合させよう!
#     for _ in range(N):
#         S = list(input())
#         grid.append(S)
#         visited = [[False]*N for _ in range(N)]
#         sx,sy = N-1,C-1
#         queue = deque()
#         queue.append((sx,sy))
        
#         visited[sx][sy] = True
        
#         while queue:
#             x,y = queue.popleft()
#             for dx,dy in dirs:
#                 nx,ny  = x+dx,y+dy
#                 #幅条件マス目と合わせる
#                 if 0<=nx<N and 0<= ny<N:
#                     if grid[nx][ny] == '.':
#                         visited[nx][ny] = True 
#                         ans.append('1')

import sys
input = sys.stdin.readline

T = int(input())

for _ in range(T):
    N, C = map(int, input().split())
    C -= 1  # 0-indexed

    grid = [list(input().strip()) for _ in range(N)]

    # low[j] = 列 j における一番下の壁の行番号
    low = [-1] * N
    for i in range(N):
        for j in range(N):
            if grid[i][j] == '#':
                low[j] = i

    # dp[i][j] = (i, j) に到達可能か
    dp = [[0] * N for _ in range(N)]

    # 初期状態：どこで止まってもいいので縦は全部OK
    for i in range(N):
        dp[i][C] = 1

    # 下から上へ DP
    for i in range(N - 2, -1, -1):
        for j in range(N):
            if dp[i][j]:
                continue

            # 下3方向のどれかから来れる？
            ok = False
            if dp[i + 1][j]:
                ok = True
            if j > 0 and dp[i + 1][j - 1]:
                ok = True
            if j + 1 < N and dp[i + 1][j + 1]:
                ok = True

            if not ok:
                continue

            # マスの種類を見る
            if grid[i][j] == '.':
                dp[i][j] = 1
            else:
                # 壁の場合：この行がその列の最下壁なら壊せる
                if low[j] == i:
                    for k in range(i + 1):
                        dp[k][j] = 1

    # 出力
    print(''.join('1' if dp[0][j] else '0' for j in range(N)))
