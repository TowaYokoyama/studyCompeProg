"""

AtCorder.ABC.311.d1 の Docstring
N×M のグリッドがあり、この上にプレイヤーがいます。
このグリッドの上から i 行目、左から j 列目をマス (i,j) と書きます。
このグリッドの各マスは 氷 か 岩 であり、その情報は N 個の長さ M の文字列 S 
1
​	
 ,S 
2
​	
 ,…,S 
N
​	
  として与えられます。

もし S 
i
​	
  の j 文字目が . なら、マス (i,j) は 氷 である。
もし S 
i
​	
  の j 文字目が # なら、マス (i,j) は 岩 である。
なお、このグリッドの外周 ( 1 行目、 N 行目、 1 列目、 M 列目の全てのマス ) は 岩 です。

最初、プレイヤーはマス (2,2) の上で停止しています。このマスは 氷 です。
プレイヤーは以下の行動を 0 度以上何度でも行うことができます。

まず、プレイヤーは上下左右の移動方向を指定する。
その後、プレイヤーは岩のマスにぶつかるまでその方向に移動する。厳密には以下の通りである。
もし移動方向に隣接するマスが 氷 なら、そのマスに移動し、同じ方向に移動を継続する。
もし移動方向に隣接するマスが 岩 なら、今いるマスに留まり、移動を終了する。
プレイヤーが触れる (通過または上で停止する) ことができる 氷 の数を求めてください。

制約
3≤N,M≤200
S 
i
​	
  は # と . からなる長さ M の文字列
i=1 または i=N または j=1 または j=M であるとき、マス (i,j) は 岩
マス (2,2) は 氷
入力
入力は以下の形式で標準入力から与えられる。

N M
S 
1
​	
 
S 
2
​	
 
⋮
S 
N
​	
 
出力
答えを整数として出力せよ。

入力例 1
Copy
6 6
######
#....#
#.#..#
#..#.#
#....#
######
出力例 1
Copy
12
例えばマス (5,5) には以下のように移動することで上で停止することができます。

(2,2)→(5,2)→(5,5)
例えばマス (2,4) には以下のように移動することで通過することができます。

(2,2)→(2,5) の移動中に (2,4) を通過する。
例えばマス (3,4) は通過することも上で停止することもできません。

入力例 2
Copy
21 25
#########################
#..............###...####
#..............#..#...###
#........###...#...#...##
#........#..#..#........#
#...##...#..#..#...#....#
#..#..#..###...#..#.....#
#..#..#..#..#..###......#
#..####..#..#...........#
#..#..#..###............#
#..#..#.................#
#........##.............#
#.......#..#............#
#..........#....#.......#
#........###...##....#..#
#..........#..#.#...##..#
#.......#..#....#..#.#..#
##.......##.....#....#..#
###.............#....#..#
####.................#..#
#########################
出力例 2
Copy
215

"""
from collections import deque 

N,M = map(int,input().split())
k = []
for _ in range(N):
    S = input()
    k.append(S)

visited = [[False]*M for _ in range(N)] #訪問済みのますか
seen_ice = [[False]*M for _ in range(N)] #「この氷マスに一度でも触れた？」

sx,sy = 1,1 #2,2をidx変換

dirs = [(-1,0),(1,0),(0,-1),(0,1)]

def bfs():
    queue = deque()
    queue.append((sx,sy))
    visited[sx][sy] = True
    seen_ice[sx][sy] = True  
    
    while queue:
        x,y = queue.popleft()
        
        for dx,dy in dirs:
            nx,ny = x,y
            
            #ここが特殊移動
            while k[nx+dx][ny+dy] == '.':
                nx +=dx
                ny+=dy 
                seen_ice[nx][ny] = True 
                
            if not visited[nx][ny]:
                visited[nx][ny] = True 
                queue.append((nx,ny))  

bfs()

ans = 0 
for i in range(N):
    for j in range(M):
        if seen_ice[i][j]:
            ans += 1 

print(ans)