"""
AtCorder.ABC.219.D の Docstring
N 種類の弁当が、それぞれ 1 個ずつ売られています。
i=1,2,…,N について、i 種類目の弁当には A 
i
​	
  個のたこ焼きと B 
i
​	
  個のたい焼きが入っています。

高橋君は、 X 個以上のたこ焼きと Y 個以上のたい焼きを食べたいです。
高橋君がいくつかの弁当を選んで買うことで、 X 個以上のたこ焼きと Y 個以上のたい焼きを手に入れることが可能かどうか判定して下さい。また、可能な場合はそのために高橋君が購入しなければならない弁当の個数の最小値を求めて下さい。

各種類の弁当は 1 個しか売られていないため、同じ種類の弁当を 2 個以上購入することは出来ないことに注意して下さい。

制約
1≤N≤300
1≤X,Y≤300
1≤A 
i
​	
 ,B 
i
​	
 ≤300
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N
X Y
A 
1
​	
  B 
1
​	
 
A 
2
​	
  B 
2
​	
 
⋮
A 
N
​	
  B 
N
​	
 
出力
高橋君が X 個以上のたこ焼きと Y 個以上のたい焼きを手に入れることが不可能な場合は −1 を出力し、 可能な場合はそのために高橋君が購入しなければならない弁当の個数の最小値を出力せよ。

入力例 1
Copy
3
5 6
2 1
3 4
2 3
出力例 1
Copy
2
高橋君は、5 個以上のたこ焼きと 6 個以上のたい焼きを食べたいです。
高橋君は 2 種類目の弁当と 3 種類目の弁当を買うことで、 たこ焼きを 3+2=5 個、たい焼きを 4+3=7 個手に入れることができます。

入力例 2
Copy
3
8 8
3 4
2 3
2 1
出力例 2
Copy
-1
高橋君がたとえすべての弁当を買ったとしても、高橋君は 8 個以上のたこ焼きと 8 個以上のたい焼きを手に入れることが出来ません。
よって、−1 を出力します。
"""

N = int(input())
X,Y = map(int, input().split())
AB = [tuple(map(int, input().split())) for _ in range(N)]
INF = 10**9

#dp[i][j] = たこ焼きi個購入,たい焼きj個を集める最小個数の弁当数
dp = [[INF]*(Y+1) for _ in range(X+1)]
dp[0][0] = 0

for A,B in AB:
  for x in range(X,-1,-1):
    for y in range(Y,-1,-1):
      if dp[x][y] == INF:
        continue
      
      nx = min(x + A,X)#ここでXを超えてくるようなら吸着
      ny = min(y + B,Y)#ここでYを超えてくるようなら吸着
      
      dp[nx][ny] = min(dp[nx][ny],dp[x][y] +1)#より少ない弁当の数で更新
      
ans = dp[X][Y]
print(ans if ans!= INF else -1)