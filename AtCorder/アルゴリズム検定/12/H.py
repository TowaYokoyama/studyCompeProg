"""
問題文
高橋君は 0 枚の金貨、 10 
9
  枚の銀貨、および X 枚の銅貨を持っています。

お店に N 個の袋が売られています。 i=1,2,…,N について、i 個目の袋は A 
i
​	
  枚の銀貨と B 
i
​	
  枚の銅貨を支払うことで買うことができます。また、i 個目の袋の中には C 
i
​	
  枚の金貨が入っており、袋を買うことでその中の金貨を手に入れることができます。

金貨 1 枚には 10 
100 
100
 
  円の、銀貨 1 枚には 10 
100
  円の、銅貨 1 枚には 1 円の価値があります。 高橋君は N 個の袋のうち好きな個数（ 0 個でも良い）の袋を買い、最終的に持っている金貨、銀貨、銅貨の価値の合計を最大にしたいです。 最終的に持っている金貨、銀貨、銅貨の価値の合計が最大となるときの、金貨、銀貨、銅貨の枚数をそれぞれ出力してください。

袋を購入するために必要な銅貨や銀貨を他の種類の硬貨で代用することはできません。 例えば、銀貨 1 枚は円に換算したときには銅貨 10 
100
  枚分の価値がありますが、それを理由に銅貨の支払いを代わりに銀貨の支払いで済ませることはできません。

制約
1≤N≤3000
0≤X≤3000
0≤A 
i
​	
 ,B 
i
​	
 ≤3000
1≤A 
i
​	
 +B 
i
​	
 
1≤C 
i
​	
 ≤3000
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N X
A 
1
​	
  B 
1
​	
  C 
1
​	
 
A 
2
​	
  B 
2
​	
  C 
2
​	
 
⋮
A 
N
​	
  B 
N
​	
  C 
N
​	
 
出力
下記の形式にしたがって、高橋君が最終的に持っている金貨、銀貨、銅貨の価値の合計が最大となるときの、金貨の枚数 P 、銀貨の枚数 Q 、銅貨の枚数 R を空白区切りで出力せよ。

P Q R
入力例 1
Copy
5 4
2 2 3
2 2 2
3 1 2
1 3 1
1 2 2
出力例 1
Copy
5 999999997 0
1 番目の袋と 5 番目の袋を買うと、高橋君は A 
1
​	
 +A 
5
​	
 =2+1=3 枚の銀貨と B 
1
​	
 +B 
5
​	
 =2+2=4 枚の銅貨を支払って、C 
1
​	
 +C 
5
​	
 =3+2=5 枚の金貨を得ます。 その後、高橋君は金貨 5 枚、銀貨 10 
9
 −3 枚、銅貨 0 枚を持っている状態であり、持っている金貨、銀貨、銅貨の価値の合計は 5×10 
100 
100
 
 +(10 
9
 −3)×10 
100
 +0×1 円で、これが考えられる最大の値です。

入力例 2
Copy
20 50
4 3 7
2 0 8
7 2 4
9 0 9
6 5 8
4 7 1
3 9 2
3 9 2
7 4 4
2 7 3
6 3 2
4 10 8
2 2 10
8 1 5
3 2 6
3 8 5
8 1 9
3 7 4
9 6 2
5 6 7
出力例 2
Copy
92 999999930 0
"""
N,X = map(int,input().split())

bags = []
for _ in range(N):
  A,B,C = map(int,input().split())
  bags.append(A,B,C)

#dp[c] = 銅貨c枚を使った時の金の最大枚数
dp = [-1] * (X+1)
dp[0] = 0

for A,B,C in bags:
  #逆順で更新
  for c in range(X-B,-1,-1):
    if dp[c] != -1:
      dp[c+B] = max(dp[c+B] , dp[c]+C)

#最大金貨枚を探す
max_gold = 0
upper_copper = 0 

for c in range(X+1):
  if dp[c] > max_gold:
    max_gold = dp[c]
    used_copper = c 

#銀貨消費を計算
used_silver = 0
remaining_gold = max_gold
remaining_copper = X - used_copper

# 金貨最大を達成する組み合わせを復元するためにもう一度探索
# （今回は銀貨制約は実質無限なので全部OK）

# 銀貨は 10^9 - 使った分
# 使った銀貨は、選んだ袋のA合計だが、
# 今回は銀貨制約が効かないので、全袋分合計しても安全

# 実は銀貨はほぼ無限なので、最大金貨を作る袋を選んだ時の銀貨消費は無視できる

# 銀貨は全部の袋のAを引く必要はない
# なぜならDPで銅貨制約だけ管理しているから、
# 銅貨使った袋だけ銀貨も消費している

# もう一度袋を復元するのは面倒なので、
# 銀貨は 10^9 - (選んだ袋のA合計)
# ただし銀貨は常に足りるので、
# 出力は以下でOK
print(max_gold, 10**9 - 0, remaining_copper)