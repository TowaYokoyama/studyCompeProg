"""
AtCorder.アルゴリズム検定.第2回.F の Docstring
問題文
N 個のタスクがあります。i 個目のタスクは A 
i
​	
  日目 (今日を 1 日目とします) またはそれ以降に実行することができ、消化することで B 
i
​	
  ポイントが得られます。

あなたは、これから 1 日ごとに、「タスクを一つ選んでそれを消化する」という行為を繰り返します。 1 以上 N 以下のすべての整数 k に対して、これから k 日間で得られるポイントの合計の最大値を求めてください。

ただし、1 以上 N 以下のすべての整数 k に対して、k 日目までに実行することのできるタスクが k 個以上存在することが保証されています。

制約
1≤N≤2×10 
5
 
1≤A 
i
​	
 ≤N
1≤B 
i
​	
 ≤100
入力中のすべての値は整数である。
入力
入力は以下の形式で標準入力から与えられる。

N
A 
1
​	
  B 
1
​	
 
A 
2
​	
  B 
2
​	
 
:
A 
N
​	
  B 
N
​	
 
出力
以下の形式で N 行出力せよ。ここで、ans 
k
​	
  はこれから k 日間で得られるポイントの合計の最大値である。

ans 
1
​	
 
ans 
2
​	
 
:
ans 
N
​	
 
入力例 1
Copy
3
1 3
2 2
2 4
出力例 1
Copy
3
7
9
1 日目に消化できるタスクは 1 番目のタスクだけなので、そのタスクを消化し、3 ポイントを得ます。k=1 の場合、これが答えです。 2 日目に消化できるタスクは 1 番目から 3 番目までのすべてです。 k=2 の場合、1 日目に 1 番目のタスクを消化し、2 日目に 3 番目のタスクを消化することで得られる 3+4=7 ポイントが得られる最大のポイントです。 k=3 の場合、3 日目までにはすべてのタスクを消化することができるので、答えは 3+2+4=9 です。

入力例 2
Copy
5
5 3
4 1
3 4
2 1
1 5
出力例 2
Copy
5
6
10
11
14
入力例 3
Copy
6
1 8
1 6
2 9
3 1
3 2
4 1
出力例 3
Copy
8
17
23
25
26
27
"""
import heapq 
N = int(input())
tasks = []
for _ in range(N):
    A,B = map(int,input().split())
    tasks.append((A,B))

#Aでソート
tasks.sort()
"""
(1,3)
(2,2)
(2,4)
"""
heap = []
ans = []
total = 0
idx = 0
for day in range(1,N+1):
    #今日使えるようになったタスクを追加
    while idx < N and tasks[idx][0] == day:
        A,B = tasks[idx]
        heapq.heappush(heap,-B)#今使えるタスクの中で B が最大のものが欲しいから符号を反転
        idx+= 1
    
    best = -heapq.heappop(heap)# 最小の値が出てくる
    total+= best
    
    ans.append(total)

for x in ans:
    print(x)