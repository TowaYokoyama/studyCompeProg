"""
AtCorder.dpまとめコンテスト.D の Docstring
N 個の品物があります。 品物には 1,2,…,N と番号が振られています。 各 i (1≤i≤N) について、品物 i の重さは w 
i
​	
 で、価値は v 
i
​	
  です。

太郎君は、N 個の品物のうちいくつかを選び、ナップサックに入れて持ち帰ることにしました。 ナップサックの容量は W であり、持ち帰る品物の重さの総和は W 以下でなければなりません。

太郎君が持ち帰る品物の価値の総和の最大値を求めてください。

制約
入力はすべて整数である。
1≤N≤100
1≤W≤10 
5
 
1≤w 
i
​	
 ≤W
1≤v 
i
​	
 ≤10 
9
 
入力
入力は以下の形式で標準入力から与えられる。

N W
w 
1
​	
  v 
1
​	
 
w 
2
​	
  v 
2
​	
 
:
w 
N
​	
  v 
N
​	
 
出力
太郎君が持ち帰る品物の価値の総和の最大値を出力せよ。

入力例 1
Copy
3 8
3 30
4 50
5 60
出力例 1
Copy
90
品物 1,3 を選べばよいです。 すると、重さの総和は 3+5=8 となり、価値の総和は 30+60=90 となります。

入力例 2
Copy
5 5
1 1000000000
1 1000000000
1 1000000000
1 1000000000
1 1000000000
出力例 2
Copy
5000000000
答えは 32-bit 整数型に収まらない場合があります。

入力例 3
Copy
6 15
6 5
5 6
6 4
6 6
3 5
7 2
出力例 3
Copy
17
品物 2,4,5 を選べばよいです。 すると、重さの総和は 5+6+3=14 となり、価値の総和は 6+6+5=17 となります。
"""
N,W = map(int,input().split())#個数と容量/限界値
wu = [tuple(map(int,input().split())) for _ in range(N)]
# print(wu)
# dp[s]はsという重さで取れる最大の価値を表すとする
dp = [0] * (W+1)

dp[0] = 0 #まだ選んでないんやったら可能状態

for w_i,v_i in wu:
    for w in range(W,w_i -1,-1):
        dp[w] = max(dp[w], dp[w-w_i] + v_i)

print(max(dp))