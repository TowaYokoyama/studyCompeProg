"""
AtCorder.dpまとめコンテスト.E の Docstring
実行時間制限: 2 sec / メモリ制限: 1024 MiB

配点 : 100 点

問題文
N 個の品物があります。 品物には 1,2,…,N と番号が振られています。 各 i (1≤i≤N) について、品物 i の重さは w 
i
​	
 で、価値は v 
i
​	
  です。

太郎君は、N 個の品物のうちいくつかを選び、ナップサックに入れて持ち帰ることにしました。 ナップサックの容量は W であり、持ち帰る品物の重さの総和は W 以下でなければなりません。

太郎君が持ち帰る品物の価値の総和の最大値を求めてください。

制約
入力はすべて整数である。
1≤N≤100
1≤W≤10 
9
 
1≤w 
i
​	
 ≤W
1≤v 
i
​	
 ≤10 
3
 
入力
入力は以下の形式で標準入力から与えられる。

N W
w 
1
​	
  v 
1
​	
 
w 
2
​	
  v 
2
​	
 
:
w 
N
​	
  v 
N
​	
 
出力
太郎君が持ち帰る品物の価値の総和の最大値を出力せよ。

入力例 1
Copy
3 8
3 30
4 50
5 60
出力例 1
Copy
90
品物 1,3 を選べばよいです。 すると、重さの総和は 3+5=8 となり、価値の総和は 30+60=90 となります。

入力例 2
Copy
1 1000000000
1000000000 10
出力例 2
Copy
10
入力例 3
Copy
6 15
6 5
5 6
6 4
6 6
3 5
7 2
出力例 3
Copy
17
品物 2,4,5 を選べばよいです。 すると、重さの総和は 5+6+3=14 となり、価値の総和は 6+6+5=17 となります。
"""

"""
①制約的に重さ→価値でdp
②初期化
③各品物を1回ずつ検討（0/1だから後ろから）
④容量W以内で作れる価値の中で最大を探す
"""
N,W = map(int,input().split())
items = [tuple(map(int,input().split()))for _ in range(N)]

max_value = sum(v for _, v in items)

INF = 10 ** 18
#制約的な判断
#dp[v] = 価値vを作る最小重さ
dp = [INF] * (max_value +1)
dp[0] = 0
for w_i, v_i in items:
  for v in range(max_value, v_i-1,-1):
    dp[v] = min(dp[v], dp[v - v_i] + w_i)

ans = 0
for v in range(max_value + 1):
  if dp[v] <= W:
    ans = v 

print(ans)