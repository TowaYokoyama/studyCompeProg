"""
AtCorder.typically90.1 の Docstring
問題文
左右の長さが L [cm] のようかんがあります。 N 個の切れ目が付けられており、左から i 番目の切れ目は左から A 
i
​	
  [cm] の位置にあります。

あなたは N 個の切れ目のうち K 個を選び、ようかんを K+1 個のピースに分割したいです。そこで、以下の値を スコア とします。

K+1 個のピースのうち、最も短いものの長さ（cm 単位）
スコアが最大となるように分割する場合に得られるスコアを求めてください。

制約
1≤K≤N≤100000
0<A 
1
​	
 <A 
2
​	
 <⋯<A 
N
​	
 <L≤10 
9
 
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられます。

N L
K
A 
1
​	
  A 
2
​	
  ⋯ A 
N
​	
 
出力
求めるスコアを出力してください。

入力例 1
Copy
3 34
1
8 13 26
出力例 1
Copy
13
左から 2 番目の切れ目で分割すると、長さ 13 [cm] のピースと長さ 21 [cm] のピースに分かれ、スコア 13 を達成できます。

入力例 2
Copy
7 45
2
7 11 16 20 28 34 38
出力例 2
Copy
12
左から 3 番目と 5 番目の切れ目で分割すると、スコア 12 を達成できます。

入力例 3
Copy
3 100
1
28 54 81
出力例 3
Copy
46
左から 2 番目の切れ目で分割すると、スコア 46 を達成できます。

入力例 4
Copy
3 100
2
28 54 81
出力例 4
Copy
26
入力例 5
Copy
20 1000
4
51 69 102 127 233 295 350 388 417 466 469 523 553 587 720 739 801 855 926 954
出力例 5
Copy
170
"""
N,L = map(int,input().split())#切れ目の数と長さcmのもの
K = int(input())#選ぶ切れ目の数
A = list(map(int,input().split()))#切れ目のいち
#最小値を最大にすると言う問題

A = [0] + A + [L]

def can_cut(x):
    cnt = 0
    last = 0
    for i in range(1, N + 2):
        if A[i] - A[last] >= x:
            cnt += 1
            last = i
    return cnt >= K + 1

left = 0
right = L + 1

while right - left > 1:
    mid = (left + right) // 2
    if can_cut(mid):
        left = mid
    else:
        right = mid

print(left)