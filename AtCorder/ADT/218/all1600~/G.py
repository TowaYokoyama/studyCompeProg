"""
AtCorder.ADT.218.all1600~.G の Docstring
問題文
高橋君が N 回コイントスを行います。 また、高橋君はカウンタを持っており、最初カウンタの数値は 0 です。

i 回目のコイントスで表裏のどちらが出たかによって、次のことが起こります。

表が出たとき：高橋君はカウンタの数値を 1 増やし、X 
i
​	
  円もらう。
裏が出たとき：高橋君はカウンタの数値を 0 に戻す。お金をもらうことは出来ない。
また、M 種類の連続ボーナスがあり、i 種類目の連続ボーナスではカウンタの数値が C 
i
​	
  になるたびに Y 
i
​	
  円もらうことができます。

高橋君は最大で何円もらうことができるかを求めてください。

制約
1≤M≤N≤5000
1≤X 
i
​	
 ≤10 
9
 
1≤C 
i
​	
 ≤N
1≤Y 
i
​	
 ≤10 
9
 
C 
1
​	
 ,C 
2
​	
 ,…,C 
M
​	
  はすべて異なる。
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N M
X 
1
​	
  X 
2
​	
  … X 
N
​	
 
C 
1
​	
  Y 
1
​	
 
C 
2
​	
  Y 
2
​	
 
⋮
C 
M
​	
  Y 
M
​	
 
出力
高橋君がもらうことのできる金額の最大値を整数で出力せよ。

入力例 1
Copy
6 3
2 7 1 8 2 8
2 10
3 1
5 5
出力例 1
Copy
48
順に 表, 表, 裏, 表, 表, 表 が出た時、もらえる金額は次のようになります。

1 回目のコイントスで表が出る。カウンタの数値を 0 から 1 にして、2 円もらう。
2 回目のコイントスで表が出る。カウンタの数値を 1 から 2 にして、7 円もらう。さらに、連続ボーナスとして 10 円もらう。
3 回目のコイントスで裏が出る。カウンタの数値を 2 から 0 にする。
4 回目のコイントスで表が出る。カウンタの数値を 0 から 1 にして、8 円もらう。
5 回目のコイントスで表が出る。カウンタの数値を 1 から 2 にして、2 円もらう。さらに、連続ボーナスとして 10 円もらう。
6 回目のコイントスで表が出る。カウンタの数値を 2 から 3 にして、8 円もらう。さらに、連続ボーナスとして 1 円もらう。
このとき高橋君は合計で 2+(7+10)+0+8+(2+10)+(8+1)=48 円もらうことができ、このときが最大です。
連続ボーナスはカウンタの数値が C 
i
​	
  になるたびに何度でももらえることに注意してください。
ちなみに、6 回のコイントスで全部表が出た時は 2+(7+10)+(1+1)+8+(2+5)+8=44 円しかもらうことが出来ず、この時は最大ではありません。

入力例 2
Copy
3 2
1000000000 1000000000 1000000000
1 1000000000
3 1000000000
出力例 2
Copy
5000000000
答えが 32 bit 整数型に収まらないこともあることに注意してください。
"""
N, M = map(int, input().split())
X = list(map(int, input().split()))

bonus = [0] * (N + 1)
for _ in range(M):
    c, y = map(int, input().split())
    bonus[c] = y

# -inf で初期化
dp = [[-1] * (N + 1) for _ in range(N + 1)]
dp[0][0] = 0

for i in range(N):
    for j in range(i + 1):  # j は最大 i
        if dp[i][j] == -1:
            continue
        
        # 表
        val = dp[i][j] + X[i] + bonus[j + 1]
        dp[i + 1][j + 1] = max(dp[i + 1][j + 1], val)
        
        # 裏
        dp[i + 1][0] = max(dp[i + 1][0], dp[i][j])

print(max(dp[N]))
