"""
AtCorder.ADT.all1800~216.F の Docstring
さ N の狭義単調増加列 A=(A 
1
​	
 ,A 
2
​	
 ,…,A 
N
​	
 ) と、長さ M の狭義単調増加列 B=(B 
1
​	
 ,B 
2
​	
 ,…,B 
M
​	
 ) が与えられます。 ここで、すべての i,j (1≤i≤N,1≤j≤M) について A 
i
​	
 

=B 
j
​	
  が成り立っています。

長さ N+M の狭義単調増加列 C=(C 
1
​	
 ,C 
2
​	
 ,…,C 
N+M
​	
 ) を、次の操作を行った結果得られる列として定めます。

C を A と B を連結した列とする。厳密には、i=1,2,…,N について C 
i
​	
 =A 
i
​	
  とし、i=N+1,N+2,…,N+M について C 
i
​	
 =B 
i−N
​	
  とする。
C を昇順にソートする。
A 
1
​	
 ,A 
2
​	
 ,…,A 
N
​	
  と B 
1
​	
 ,B 
2
​	
 ,…,B 
M
​	
  がそれぞれ C では何番目にあるか求めてください。 より厳密には、まず i=1,2,…,N について C 
k
​	
 =A 
i
​	
  を満たす k を順に求めたのち、j=1,2,…,M について C 
k
​	
 =B 
j
​	
  を満たす k を順に求めてください。

制約
1≤N,M≤10 
5
 
1≤A 
1
​	
 <A 
2
​	
 <⋯<A 
N
​	
 ≤10 
9
 
1≤B 
1
​	
 <B 
2
​	
 <⋯<B 
M
​	
 ≤10 
9
 
すべての i,j (1≤i≤N,1≤j≤M) について A 
i
​	
 

=B 
j
​	
 
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N M
A 
1
​	
  A 
2
​	
  … A 
N
​	
 
B 
1
​	
  B 
2
​	
  … B 
M
​	
 
出力
答えを 2 行で出力せよ。
1 行目には A 
1
​	
 ,A 
2
​	
 ,…,A 
N
​	
  がそれぞれ C では何番目にあるかを空白区切りで出力せよ。
2 行目には B 
1
​	
 ,B 
2
​	
 ,…,B 
M
​	
  がそれぞれ C では何番目にあるかを空白区切りで出力せよ。

入力例 1
Copy
4 3
3 14 15 92
6 53 58
出力例 1
Copy
1 3 4 7
2 5 6
C は (3,6,14,15,53,58,92) となります。 A=(3,14,15,92) の要素はそれぞれ 1,3,4,7 番目にあり、B=(6,53,58) の要素はそれぞれ 2,5,6 番目にあります。

入力例 2
Copy
4 4
1 2 3 4
100 200 300 400
出力例 2
Copy
1 2 3 4
5 6 7 8
入力例 3
Copy
8 12
3 4 10 15 17 18 22 30
5 7 11 13 14 16 19 21 23 24 27 28
出力例 3
Copy
1 2 5 9 11 12 15 20
3 4 6 7 8 10 13 14 16 17 18 19
"""

N,M = map(int,input().split())
A = list(map(int,input().split()))
B = list(map(int,input().split()))

pos_A = [0]*N
pos_B = [0]*M

i = 0
j = 0
k = 1

while i < N and j < M:
    if A[i] < B[j]:
        pos_A[i] = k
        i += 1
    else:
        pos_B[j] = k
        j += 1
    k += 1

while i < N:
    pos_A[i] = k
    i += 1
    k += 1

while j < M:
    pos_B[j] = k
    j += 1
    k += 1

print(*pos_A)
print(*pos_B)



