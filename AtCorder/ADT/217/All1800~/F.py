"""
AtCorder.ADT.217.All1800~.F の Docstring
橋君は N 日間の鉄道旅行を計画しています。
高橋君はそれぞれの日について、運賃の通常料金を払うか、1 日周遊パスを 1 枚使用するか選ぶことができます。

ここで、1≤i≤N について、i 日目の旅行にかかる運賃の通常料金は F 
i
​	
  円です。
一方、1 日周遊パスは D 枚セットで P 円で発売されており、何セットでも購入することが可能ですが、D 枚単位でしか購入することができません。
また、購入したパスは 1 枚ずつ好きな日に使うことができ、旅行が終了した時点で余っていても構いません。

N 日間の旅行でかかる金額、すなわち 1 日周遊パスの購入にかかった代金と、1 日周遊パスを利用しなかった日における運賃の通常料金の合計金額の和としてあり得る最小値を求めてください。

制約
1≤N≤2×10 
5
 
1≤D≤2×10 
5
 
1≤P≤10 
9
 
1≤F 
i
​	
 ≤10 
9
 
入力はすべて整数
入力
入力は以下の形式で標準入力から与えられる。

N D P
F 
1
​	
  F 
2
​	
  … F 
N
​	
 
出力
N 日間の旅行でかかる金額としてあり得る最小値を出力せよ。

入力例 1
Copy
5 2 10
7 1 6 3 6
出力例 1
Copy
20
1 日周遊パスを 1 セットだけ購入し、1 日目と 3 日目に使用すると、合計金額は (10×1)+(0+1+0+3+6)=20 となり、このときかかる金額が最小となります。
よって、20 を出力します。

入力例 2
Copy
3 1 10
1 2 3
出力例 2
Copy
6
3 日間すべてにおいて運賃の通常料金を支払ったときに最小となります。

入力例 3
Copy
8 3 1000000000
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
出力例 3
Copy
3000000000
1 日周遊パスを 3 セット購入し、8 日間すべてにおいて 1 日周遊パスを利用したときに最小となります。
答えが 32 bit 整数型に収まらないことがあることに注意してください。
"""
N, D, P = map(int, input().split())
F = list(map(int, input().split()))

F.sort(reverse=True)

# 累積和
prefix = [0]
for f in F:
    prefix.append(prefix[-1] + f)

ans = float('inf')

for k in range(N // D + 2):  # 余裕を持たせる
    use = min(N, k * D)#パスで消せる日数
    cost = k * P + (prefix[N] - prefix[use])#パス代 + パスを使わなかった日の合計
    ans = min(ans, cost)

print(ans)
